
生产者

一、生产者发送消息
1、同步发送：如果生产者发送消息后，没有收到ack，生产者会阻塞，阻塞0.1秒(可以配置，默认100ms)后继续重试，重试三次,当然也可能造成消息的重复发送，
比如当发生网络抖动的时候，所以需要接收者那边做好消息接收的幂等性处理
2、异步发送：不会阻塞，生产者发送完消息后就可以执行之后的业务，broker在收到消息后异步调用生产者提供的回调callback函数
(虽然可以提升性能，但是容易丢失消息，用得少)

二、关于生产者ack的配置(只有同步情况下才有意义)
ack=0 只要集群收到消息，不需要任何broker收到消息，立即返回ack，效率最高，但是最容易丢消息
ack=1 多副本之间的leader已经收到消息，并把消息写入本地的log中，才会返回给生产者，还没向其他副本进行同步  性能和安全性是最均衡的
ack=-1/all(还有一个配置，min.insync.replicas=2,默认是1，推荐大于等于2，2表示leader和另一个broker都收到消息才返回ack) 性能最差，最安全的
解析，当ack=1时，leader先把数据写到log后才去同步其他broker，当写完刚好挂了，就会出现丢失数据。

三、发送消息的缓冲区机制
kafka的生产者会创建一个消息缓冲区，大小为32M(可配)，我们发送的数据会先放到这个缓冲区中，然后生产者有一个本地线程会从缓冲区中去拿数据，然后进行发送，
这个线程每次最多拉16K如果数据没达到16K(可配)，那10ms后也会将已有数据发给broker，因此只有一条数据也能发送
------------------------------------------------------------------------------------------------------------------------

消费者

一、offset的自动提交和手动提交(可配置)
提交的内容：无论是哪一种提交，消费者都需要把消费组+消费的某个主题+消费的某个分区及消费的偏移量，这样的信息提交到集群的_consumer_offsets主题里面
1、自动提交，消费者把消息poll下来后(可能多条)，立即提交offset
自动提交有可能会导致消息丢失，当消费者提交offset后宕机了，下一个消费者也拿不到之前的消息了，之前未消费的消息就丢失了
2、手动提交，等把消息消费了再去提交offset
(1)手动同步提交(常用，一般使用同步提交，因为提交之后一般没什么逻辑了)
会阻塞，直到broker返回ack。
(2)手动异步提交
不会阻塞，broker返回ack后会回调函数


长轮询Poll消息，消费者和broker建立了长连接，是一个长轮询的poll
ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(1000));
默认poll一次拉500条消息，但是指定时间表内即使没有500条，也返回，如果一次就拉到500条，则不需要等待
(可以修改poll消息数，根据具体的消费速度去配置)

两次Poll超过30秒，说明消费能力太弱，会被提出消费组


