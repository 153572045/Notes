
fighting目录中的java文件也有类加载相关笔记

一、类加载

类加载指的是将class文件中的数据加载到内存中(运行时数据区中的方法区)，进过一系列处理，最终形成可以被虚拟机使用的java类型。
类加载的特性：在运行期间进行加载，这样的优缺点如下：
优点：扩展性和灵活性很高，可以在运行时才去确定和加载一个接口的实际类型，甚至可以从网络上获取一个二进制流作为程序代码的一部分
缺点：让提前编译的工作变得比较困难，也让类加载时增加一点性能开销

上述的一系列处理指的是类的加载->验证->准备->解析->初始化->使用->卸载

类的加载，验证、准备和解析的时机没有明确的规定，但初始化的时机是在类被主动引用时进行，在此之前要进行之前的流程。被动引用则不会触发初始化过程。
类的主动引用主要包括了以下的行为：
1、new 一个类型的对象
2、使用一个类型的静态变量或静态方法，被字面值赋值的静态常量除外(原因：在编译阶段进行了常量传播优化，下面被动引用例子3)
3、使用一个类型的Class对象
4、初始化一个类型时，其父类也要初始化
5、实现了default方法的接口的实现类初始化之前，该接口要先初始化等

被动引用的例子：
1、通过子类引用父类的静态字段，不会导致子类初始化
2、new一个类型的数组，该元素类型不会初始化，初始化的是一个由虚拟机产生的数组类型
3、使用一个类的静态常量，如类中定义public static final String HELLOWORLD = "hello world";
若另一个类中引用了HELLOWORLD,在编译期间会将这个常量加载引用类的常量池，因此运行时不会对定义类有引用，
也就是说这两个类之间没有关系了(进行了编译阶段的常量传播优化)



各阶段的细节

一、加载：
1）获取类的二进制字节流(class文件)。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3）生成一个Class对象，作为方法区对这个类的访问入口。
数组比较特殊，本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的，但是数组的元素类型需要靠类加载器加载

二、验证：
大致会进行以下几种验证
1、文件格式的验证   校验二进制流是否符合class文件格式规范
2、元数据验证      我理解应该是从语言级别进行验证，譬如校验类是否继承了final类，非抽象类是否没有实现接口方法或父类抽象方法
3、字节码验证
4、符号引用验证

三、准备：对类变量进行零值初始化
在方法区上(逻辑上的概念，实际上在Jdk8后也放在堆里面)给静态变量分配内存并将这些静态变量初始化为对应类型的零值，静态常量初始化为具体的值

四、解析，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

五、初始化 ：虚拟机真正执行类中的代码，将主导权移交给应用程序。
主要进行了静态变量(类变量)的初始化，具体是执行<clinit>()类构造方法  该方法由编译器生成，按顺序收集了静态变量的赋值动作和初始化块，当有多个线程同时初始化
一个类时，只有一个线程能执行clinit方法，其他阻塞等待。
clinit方法不是必有的，如果一个类没有对静态变量赋值，也没有静态语句块，可以不生成

六、对象的实例化过程
1、检查类是否已被加载，没有则进行加载
2、给对象分配内存
3、进行零值初始化和对象头初始化
4、执行构造函数 <init>()


二、双亲委派模型
双亲委派模型的工作过程是：一个类加载器要加载一个类的时候，首先委派给父加载器去加载，除了启动类加载器，其他加载器都这样
只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。


优点：
1.避免类的重复加载，当父亲已经加载了该类时，子类加载器就没有必要再加载一次。
2.避免Java核心类库中的类不会被随意替换，保证了程序的稳定性。

破坏双亲委派模型
并不是一个强约束的模型，而是Java设计者们推荐给开发者的一种类加载器实现的最佳实践。


三、自定义类加载器：https://www.jianshu.com/p/cbf5b042e01e
自定义概述：
重写loadClass()或者findClass()这两个方法，建议重写后者，因为loadClass方法实现了双亲委派模型的逻辑，
重写的思路大概是获取要加载的类的class文件的字节数组，然后调用defineClass方法(native方法)。

类加载器有两种，一种是虚拟机内部的启动类加载器（BootstrapClassLoader），是用C++写的，属于虚拟机的一部分，另一种独立于虚拟机外部，用java写的，
全部继承自抽象类java.lang.ClassLoader
绝大部分类都由系统提供的三个类加载器进行加载
1、启动类加载器（Bootstrap ClassLoader）,负责加载在\lib目录下的类库，该加载器无法被程序直接引用，
2、扩展类加载器（Extension ClassLoader），负责加载\lib\ext目录中的类库
3、应用程序类加载器（AppClassLoader）,负责加载用户类路径上的所有类库，程序的默认类加载器



