
资料：https://juejin.cn/post/6844903889678893063#heading-8

一、使用线程池的原因
1、降低资源的消耗：线程池可以重复利用线程，减少了频繁创建或销毁线程的开销
2、提高响应速度：一个任务到达时，不需要等待线程的创建，可以直接使用已有的线程
3、提高线程的可管理性
------------------------------------------------------------------------------------------------------------------------
二、线程池的构造函数即其参数意义

public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
   BlockingQueue<Runnable> workQueue,
   ThreadFactory threadFactory,
   RejectedExecutionHandler handler)
几个核心参数的作用：
corePoolSize： 线程池核心线程数最大值
maximumPoolSize： 线程池最大线程数大小
keepAliveTime： 线程池中非核心线程空闲的存活时间大小
unit： 线程空闲存活时间单位
workQueue： 存放任务的阻塞队列
threadFactory： 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。
handler：  线城池的饱和策略事件，主要有四种类型。
------------------------------------------------------------------------------------------------------------------------
三、四种拒绝策略

AbortPolicy(抛出一个异常，默认的)
DiscardPolicy(直接丢弃任务)
DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）
CallerRunsPolicy（交给线程池调用所在的线程进行处理)
------------------------------------------------------------------------------------------------------------------------
四、线程池的异常处理
在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法
感知任务出现了异常，因此我们需要考虑线程池异常情况。
处理线程池异常的方式主要有以下4种：
1、在任务代码中加入try/catch结构进行捕获。
2、使用submit()方法,如果任务代码出现异常，如果调用返回的Future对象的get()方法可以进行捕获。
3、自定义创建线程的工厂类，然后给生产的线程设置UncaughtExceptionHandler。
4、自定义ThreadPoolExecutor，然后重写afterExecute方法也可以对异常进行处理。