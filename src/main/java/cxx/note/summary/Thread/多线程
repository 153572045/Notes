内存模型指的是在特定的协议下，对特定内存或高速缓存进行读写的抽象过程
Java内存模型的主要目的是定义程序中各种变量的访问规则

为了解决处理器的处理速度和内存读写速度之间的矛盾，计算机引系统引入了高速缓存，在java中对应着线程内的工作内存。高速缓存会导致缓存数据不一致的问题，
解决方案是使用缓存一致协议（如MESI），各个处理器在访问缓存时要遵循这些协议。

工作内存相当于虚拟机栈中的部分区域，和TLAB不一样，TLAB只是为了防止给对象分配空间的时候出现线程安全问题，实际上还是主存区域。
从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储
于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。


工作内存存储着主存内的对象副本，但是不会复制整份对象到工作内存中，只会复制在线程中会被访问到的字段
即使是volatile变量也会在工作内存中存在副本，只不过因为其特殊规则使得线程对该对象的操作如同直接在内存上操作一般

关于volatile变量
volatile是虚拟机提供的最轻量级的同步机制
其用来保证变量在所有线程中的可见性，但是从物理角度上看，即使是volatile变量，在各个线程的工作内存中也不一定一致，只不过是因为每次要使用的时候
（传递给执行引擎）都会先刷新，因此执行引擎看不到不一致的情况，因此可以认为不存在一致性问题。
但是volatile变量并不能保证在并发下是安全的，因为Java的运算操作符并非原子操作。
volatile的第二个语义是禁止指令重排
volatile变量的赋值语句处会插入一个lock前缀的指令，叫内存屏障，指令无法越过屏障进行重排。
lock指令会使本处理器的缓存写入主存，同时使得其他处理器的缓存无效，相当于对volatile变量做了一次store和write操作

java内存模型对volatile变量的规则：
user和read,load相关联，必须连续且一起出现------------保证使用的volatile变量都是主存的最新值
assign和store,write相关联，必须连续且一起出现--------------保证每次修改完volatile变量后立刻刷回主存

java内存模型用来保证原子性变量操作的动作有 read、load、use、assign、store、write这六个，基本数据类型的访问、读写都是具备原子性的(long,double除外)
如果应用场景需要更大范围的原子性保证，可以使用lock和unlock动作，这两个操作并未开发给用户直接使用，而是使用更高层次的字节码 monitorenter和monitorexit
来隐式使用这两个操作，在代码就是synchronized关键字
lock也能保证可见性，unlock操作之前，必须把该变量同步刷回主内存（执行store,write操作）
final关键字也能保证可见性，被final修饰的字段在构造器中一旦被初始化完，那么在其他线程中就能看见final字段的值。


综上：synchronized可以保证原子性，可见性和有序性
volatile通过禁止指令重排保证有序性，而synchronized是因为某一时刻只有一个线程能进入临界区，因此同一个锁的同步块只能串行执行。

