内存模型指的是在特定的协议下，对特定内存或高速缓存进行读写的抽象过程

java内存模型概述：
java线程是运行在自身的工作内存之上，不与主内存直接进行交互，可以类比于物理机的高速缓存和主存，目的是为了提高运行效率
线程之间的数据传输只能通过主存作为媒介来进行，即共享变量
java内存模型定义了主内存和工作内存之间的交互协议，以及各种变量的访问规则，比如有特殊访问规则的volatile变量

------------------------------------------------------------------------------------------------------------------------
为了解决处理器的处理速度和内存读写速度之间的矛盾，计算机引系统引入了高速缓存，在java中可以类比到线程内的工作内存，因为工作内存一般会优先存储到寄存器
或高速缓存中。

高速缓存会导致缓存数据不一致的问题，解决方案是使用缓存一致协议（如MESI），各个处理器在访问缓存时要遵循这些协议。

工作内存相当于虚拟机栈中的部分区域，和TLAB不一样，TLAB只是为了防止给对象分配空间的时候出现线程安全问题，实际上还是主存区域。
从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储
于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。

工作内存存储着主存内的对象副本，但是不会复制整份对象到工作内存中，只会复制在线程中会被访问到的字段
即使是volatile变量也会在工作内存中存在副本，只不过因为其特殊的访问规则使得线程对该对象的操作如同直接在内存上操作一般
------------------------------------------------------------------------------------------------------------------------
内存间的交互：
主内存和工作内存之间的交互协议，由Java内存模型定义的8种原子操作(内存访问操作)，以及它们之间的一些规则限定，比如执行顺序、依赖关系等来确定的
------------------------------------------------------------------------------------------------------------------------
关于volatile变量--------虚拟机提供的最轻量级的同步机制
java内存模型专门为volatile变量定义了一些访问规则来保证其可见性：1、use动作和read、load动作是相关联的，必须连续且一起出现
                                                      2、assign动作和store、write动作是相关联的，必须连续且一起出现
                                                      如何保证的： 用lock前缀的指令保证的，该指令会导致执行store write操作，该操作
                                                      又会导致其他线程该缓存无效

lock前缀指令的本质：导致执行store write操作，即将修改同步回主存，该行为也是导致禁止指令重排的原因。

volatile的两项特性：
一、保证可见性：对volatile变量的修改（写操作）都能立刻反映到其他线程之中-----换句话说，由于volatile变量的特殊访问规则，使得线程对该类对象的操作如同直接在内存上操作一般

volatile变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次
使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题） 对volatile变量赋值后，会引起其他线程该缓存失效。
注：由于Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发环境下一样是不安全的。

二、禁止指令重排：
(关于指令重排的描述：为了保证运算效率，充分利用运算单元，虚拟机没有禁止指令重排，在并发环境下，若一个线程依赖于另一个线程的中间结果，指令重排就会导致
另一个线程运行出错，比如配置读取问题。在一个线程内，指令重排后的执行结果和按照代码顺序执行的结果必须保持一致(根据数据依赖的方式去限制重排)，因此在同
一个线程内是感知不到指令重排的情况的。)
禁止指令重排的原理：
对于volatile变量，其赋值语句后面会多执行一条以lock为前缀的指令，这个操作的作用相当于一个内存屏障，指令重排序无法越过内存屏障，
该操作将本处理器的缓存写入了内存，同时引起其他处理器的缓存失效，相当于执行了一次“store和write”操作。
由于指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。

三、其他
如果应用场景需要更大范围的原子性保证，可以使用lock和unlock动作，这两个操作并未开发给用户直接使用，而是使用更高层次的字节码 monitorenter和monitorexit
来隐式使用这两个操作，在代码就是synchronized关键字
lock也能保证可见性，unlock操作之前，必须把该变量同步刷回主内存（执行store,write操作）
final关键字也能保证可见性，被final修饰的字段在构造器中一旦被初始化完，那么在其他线程中就能看见final字段的值。

综上：synchronized可以保证原子性，可见性和有序性
volatile通过禁止指令重排保证有序性，而synchronized是因为某一时刻只有一个线程能进入临界区，因此同一个锁的同步块只能串行执行。
------------------------------------------------------------------------------------------------------------------------
先行发生原则
若A先行发生于B，那么A的操作对于B来讲是可以观察到的
若不存在天然的先行发生关系，那么顺序性则无法得到保证，虚拟机可以按任意顺序进行执行

1、程序次序规则：在同一个线程内，代码按照控制流的顺序执行
2、管程锁定规则：解锁操作先行发生于后面的加锁操作（对同一个锁）。
3、volatile变量规则：volatile变量的写操作先行发生于后面对这个变量的读操作
4、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测
6、对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
7、传递性规则：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论