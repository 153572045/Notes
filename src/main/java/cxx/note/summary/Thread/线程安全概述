
什么是线程安全？
首先线程安全描述的是某个对象，而不是整个程序。
当一个对象被多个线程同时访问的时候，若各个线程不需要进行一些额外的同步措施，访问这个对象的行为都能得到正确的结果，那么就称这个对象是线程安全的。
线程安全的代码都必须具备一个共同特征：代码本身做了足够的同步保障手段（如互斥同步等），令调用者无须关心多线程下的调用问题
------------------------------------------------------------------------------------------------------------------------
同步手段

一、使用volatile变量，也是最轻量级的同步手段

二、非阻塞同步，也就是乐观锁策略，主要由CAS算法支持(CAS操作由sun.misc.Unsafe类实现)  -----待续

三、互斥同步，也就是加锁，由synchronized方法或Lock对象支持
1、synchronized:
synchronized会在方法或者代码块的前后分别插入monitorenter和monitorexit指令，作用就是获取某一个对象的锁，拿不到则阻塞
synchronized的锁是可重入的
使用重量级锁的缺点：要阻塞或唤醒某一个线程，需要操作系统帮忙，这就涉及到用户态和内核态之间的转换，影响性能。(虚拟机优化：会在通知操作系统进行阻塞某
条线程之前先进行一段自旋等待过程)
2、Lock对象
实现了java.util.concurrent包中Lock接口的锁对象也可以实现synchronized的功能，相对于synchronized，其拥有的新功能有：
(1)、等待可中断,即设置一个超时等待(2)、可以实现公平锁，但性能或受到影响(3)、可以绑定多个条件对象，在对象上执行newCondition()方法，对应的休眠和唤
醒接口为condition.await(),condition.signalAll() (4)可以尝试非阻塞获得锁 (5) 能中断获得锁 第120页
3、优略势
Lock更加灵活，在类库层面去实现同步，而synchronized是在语言的层面上去实现同步的
Lock支持新的功能
缺点是需要主动释放锁，容易出错
synchronized则由虚拟机管理，即使抛出异常也会被释放，另一个是虚拟机可以在线程和对象的元数据中记录synchronized锁的相关信息，便以优化

四、可重入代码
不依赖全局变量、或堆上的数据，用到的状态量都由参数中传入，不调用非可重入的方法等。

五、其他
因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄
存器值、变量等，以便内核态调用结束后切换回用户态继续工作。

------------------------------------------------------------------------------------------------------------------------
锁优化
为了更高效地在线程之间共享数据及解决竞争问题，进行了以下的锁优化

1、自旋锁：为了尽量避免了线程切换带来的开销，在线程需要锁的时候可以进行一段时间的自旋等待
自适应自旋，虚拟机采取一些监控机制，可以自适应调整自旋的次数，以此来提高效率。
2、锁消除：即时编译器在运行时，对一些加锁的代码，但实际上不可能存在共享数据竞争的锁进行消除，减去一些不必要的开销
3、锁粗化：在一系列连续操作中对同一个对象反复加锁和解锁，或者在一个循环体内进行反复的加锁解锁，这样即使不存在线程竞争的情况也会导致不必要的性能损耗。
虚拟机会扩大加锁的范围到整个操作序列的外部，

重点：
重量级锁是操作系统以互斥量的形式实现的，性能消耗较高，因此有了下述两种优化
注：以下两种锁并不是要来代替重量级锁的，而是在特定的场景下(没有多线程竞争或者竞争程度较低)，作为重量级锁的一个前置方案，减少重量级锁的使用
以此来提高性能

4、偏向锁
偏向锁也是JDK6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能
偏向锁会偏向于第一个获得它的线程
加锁过程：
1、判断锁对象是否可偏向、即检查Mark Word中的锁标志位和偏向模式是否分别为01和1。
2、确认为可偏向后检测锁对象上的线程ID是否指向本线程，如果是的话则进入同步块执行，不是进入3
3、不是的话用CAS去修改锁对象上的线程ID为本线程ID，成功后进入同步块执行
4、若失败则表示有竞争，偏向锁将被撤销
撤销过程：
若有第二个线程去竞争偏向锁时，偏向锁则会被撤销，否则偏向锁不会被主动释放
撤销偏向锁会导致STW，即在到达全局安全点时，拥有偏向锁的线程被挂起，偏向锁会被升级为轻量级锁或重量级锁，取决于当前是否被锁定状态(?,目前的理解应该是
是否处于同步块中)


5、轻量级锁

轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了
使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。

加锁过程：
1、首先检查同步对象是否被锁定(锁标志位为01)
2、虚拟机在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word
3、虚拟机用CAS操作将锁对象的MW更新成指向Lock Record的指针，若修改成功则表示加锁成功 锁标志位改成00

膨胀成中重量级锁：
若上述第三步没有成功或者在加锁期间有其他线程来竞争锁，则需要膨胀成重量级锁，竞争线程会去修改锁对象的MW，之后进入自旋等待或阻塞状态，拥有锁的线程
在释放锁的时候发现锁对象的MW已被修改过了，则将锁切换到重量锁，同时唤醒阻塞线程。



















