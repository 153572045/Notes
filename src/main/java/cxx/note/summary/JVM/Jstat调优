
JVM调优主要目的是优化FGC，FGC减少了 停顿时间大量减少，因为Full gc的停顿时间一般是minor gc的十倍以上 而且OOM基本不会出现
尽量减少触发对象从新生代挪到老年代的规则-

1、进行JVM运行情况预估，通过以下方法可以估算出程序运行时的一个内存使用模型
知道系统在运行时的一个内存情况

使用jstat -gc 进程id 间隔时间 次数    可以算出一些关键数据，就可以进行调优，先给自己的系统设置一些初始性的JVM参数，比如堆内存的大小，年轻代
的大小，伊甸区和幸存区的大小，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值。

可以通过jstat工具计算出来的数据包括以下几种：

1、年轻代对象的增长速率，即根据伊甸区的变化估算出每秒大概新增多少对象，如执行命令
jstat -gc 进程id 1000 10 观察每秒eden区新增了多少对象，如果系统负载不高，可以把频率调低，如1分钟一次甚至10分钟一次，当然系统可能会有高峰期和
日常期，应该在不同时期进行分别估算。  知道了这个数据可以推算YGC的频率

2、YGC的触发频率和每次耗时
知道了年轻代的增长速率，就能根据伊甸区的大小推算出YGC大概多久做一次，YGC的平均耗时可以通过YGCT/YGC算出，根据结果我们大概就能知道系统会多久因为YGC
而卡顿多久

3、每次YGC后有多少对象存活或进入老年代
知道了YGC的频率，比如5分钟一次，就可以执行命令jstat -gc pid 3000000 10,观察各个内存区域的变化，在每次gc后eden的使用一般会大幅度减少，survivor
和老年代都可能会增长，这些增长就是YGC的存活对象，就可以看出每次YGC后老年代大概增长多少对象，从而推算出老年代对象的增长速率

4、Full GC 的触发频率和每次耗时
知道了老年代的增长速率就可以推算出Full Gc的触发频率，每次耗时可以通过FGCT/FGC算出

优化思路：
简单来讲就是尽量让每次YGC后存活的对象小于Survivor区域的50%，都留在年轻代里，尽量别让对象进入老年代，从而减少Full Gc的次数，避免频繁Full Gc对
性能造成较大的影响
------------------------------------------------------------------------------------------------------------------------
新生代到达老年代的规则

1、大对象直接进入老年代(比如数组或字符串)，JVM参数 -XX：PretenureSizeThreshold可以设置大对象的大小，若对象大小超过这个大小会直接进入老年代
而不会进入年轻代，这个参数只有在Serial和ParNew两个收集器下才有效
大对象直接到老年代的原因：为了避免为大对象分配内存时的复制操作而降低效率

2、长期存活的对象进入老年代
每熬过一次MinorGc,对象的分代年龄会增加1岁，当增长到一定程度(默认15岁，CMS 6岁，不同收集器可能会不同)，就会晋升到老年代，可以通过参数
-XX：MaxTenuringThreshold来设置年龄阈值


3、对象动态年龄判断
当Survivor区域存放的对象大小超过了50%(可以用-XX:TargetSurvivorRatio修改)，那么此时大于等于这个区域内对象年龄最大的对象就可以直接进入老年代
这个规则是希望那些可能是长期存活的对象尽早进入老年代，对象动态年龄判断机制一般是在minor gc之后触发.
个人见解：survivor一般是不会有这么多对象的，有这么多的话复制压力会比较大，因此希望可能长期存活的对象尽快进入老年代，不用进行15次复制。

4、老年代的空间分配担保机制
年轻代每次进行minor gc之前JVM都会计算下老年代的剩余空间
如果这个可用空间小于年轻代中所有对象的大小之和
就会检查一个(-XX:-HandlePromotionFailure参数是否设置了，jdk1.8默认设置了)，如果有这个参数，就会将老年代的可用内存和之前每一次minor gc后进入
老年代对象的平均大小作比较，如果小于这个平均值或者没有设置以上的参数，就会触发一次Full gc,对老年代和年轻代一起回收一次垃圾。
当然，如果大于平均值，直接进行minor gc之后老年代的大小无法存放新增的部分，还是会触发Full gc,再不行就OOM



