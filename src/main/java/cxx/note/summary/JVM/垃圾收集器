
1、GC root根对象一般有哪些
有线程栈中引用的对象，方法区中的静态变量、静态常量引用的对象，虚拟机内部引用的一些对象，比如一些异常对象，基本数据类型的Class对象，还有被锁持有的
对象，非收集区存在跨代引用的对象

各种垃圾收集器

1、Serial收集器
Serial收集器是一个单线程的垃圾收集器，它在收集的时候需要STW，暂停用户线程，主要的特点是比较简单高效，暂用的资源少，毕竟单线程工作没有线程切换的开销，
一般可以用于一些资源受限的客户端系统。 在资源充足的服务端系统就不太适用

2、ParNew收集器
这个收集器是Serial收集器的一个多线程版本，即会使用多个线程同时去进行垃圾回收工作，在多CUP环境下效率会比Serial收集器高，但单CUP环境下效率就没有
Serial收集器的效率高了，目前是和CMS绑定在一起了

3、Parallel Scavenge收集器
这款收集器关注于实现可控吞吐量，就是说它可以控制每次垃圾回收的最长回收时间或者执行垃圾回收的时间和用户线程执行时间的比例，提供了两个参数供我们配置。
当然这种实现是以牺牲吞吐量和新生代空间为代价换取的，就是说加入你把回收时间设置得很短，意味着新生代的空间就变小了，虽然每次回收的时间变少了，但是系统
的整体吞吐量就下降了。

4、Serial Old收集器
是Serial的老年代版本，这个用的是标记整理，而Serial用的是标记复制，是CMS的备用方案

5、Parallel Old收集器
是Parallel Scanvenge的老年版本

6、CMS
CMS是一款专注于低停顿的垃圾收集器，它的收集过程包括了四个阶段:
1）初始标记 ：仅仅标记了GC根对象能直接关联到的对象
2）并发标记 ：遍历整个对象图
3）重新标记 ：以增量更新的方式修正了并发标记期间的一些引用的改变
4）并发清除 ：清除死亡对象
这四个阶段除了初始标记和重新标记需要STW，剩下两个阶段都可以和用户线程并发执行，且需要STW的那两个阶段耗时相对都比较少，所以CMS大致可以看成
可以和用户线程并发执行的垃圾收集器。
缺点： 1、毕竟需要保证和用户线程并发执行且结果正确，需要做很多额外的操作，并且并发期间暂用了一些CUP资源，所以肯定会影响到系统的吞吐量
     2、无法处理并发标记期间产生的浮动垃圾，而且进入垃圾回收阶段还需要预留空间供用户线程使用，预留多少空间也是一个需要考虑的问题，预留少了
     有可能出现内存溢出的现象，这个时候会采用Serial Old作为备用方案，是需要STW，预留多了会使系统的垃圾回收变得更加频繁，也会影响系统的吞吐量
     3、还有一个就是会产生空间碎片，当然碎片化到一定程度会进行整理，但是整理又会使得停顿时间增长


7、G1
Gi收集器开创了面向局部收集的设计思路和基于Region的内存布局形式，就是说它不再和其他垃圾收集器那样将推分为新生代和老年代两个固定区域，而是
将推划分为许多个大小相同的Region区域，各个Region即可以充当新生代又可以充当老年代的角色，收集器会用不同的策略去收回垃圾
它的回收过程包括了四个阶段
1、初始标记 2、并发标记 3、最终标记(用初始快照STAB)  4、筛选回收
它的一个核心的思想是建立一个可预测的停顿时间模型，垃圾收集器会跟踪每个Region区域的垃圾堆积价值大小，在筛选回收阶段会将这些Region区域按回收效益
做一个排序，并根据给定的停顿时间制定回收计划进行回收。
相对于CMS,G1器除了并发标记外，其余阶段也是要完全暂停用户线程的，所以它并非纯粹地追求低延迟，而是在延迟可控的情况下获得尽可能高的吞吐量。

优点：优化空间更大，吞吐量高