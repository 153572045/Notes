BIO
同步并阻塞(传统阻塞型)，服务器实现模式为一个连接对应一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接什么都不做，就会
造成不必要的线程开销。
当其中一个线程在等待客户端的数据时(执行read函数)，线程会阻塞直至有数据。

bio就是传统的java io编程，相关的接口在java.io中

在编程中的具体实现步骤
一、服务端：
1、通过ServerSocket注册端口(这样就具备了端口被访问的能力)
ServerSocket ss = new ServerSocket(9999);
2、服务端通过调用accept()方法用于监听客户端的Socket请求
Socket socket = ss.accept();
3、从Socket中获取字节输入流或输出流进行数据的读写操作
InputStream is = socket.getInputStream();
这个输入流怎么写怎么读需要服务端和客户端先约定好，具体的使用可以将字节输入流包装成一个缓冲字节输入流
BufferedInputStream bis = new BufferedInputStream(is)；
再包装成缓冲字符输入流:
BufferedReader br = new BufferedReader(new InputSstreamReader(is));
String msg;
while((msg = br.readLine()) != null) {  //在该处由于调用了readLine()方法，所以会被阻塞直到客户端发来一行信息，如果没有换行符，那么也会一直等
    System.out.PrintLn("服务端收到:" + mst);
}


二、服务端
1、通过Socket对象请求与服务端的连接(即调用connet方法，该方法和服务端的accept方法交互，即在进行TCP的三次握手过程，连接成功后双方都获得一个
socket对象,便可以用这个对象进行通信，这个对象是对底层TCP/IP协议族实现的一个封装)
Socket socket = new Socket("127.0.0.1", 9999);  //connet函数应该直接被封装在构造函数中，因此不用调用
2、从Socket中得到字节输入或者是字节输出流进行数据的读写操作
OutputStream os = socket.getOutputStream();
PrintStream ps = new PrintSream(os);
ps.print("hello");  //对应上面的服务端，由于没有换行符，所以服务端不会进入while结构内，即使收到信息也会处于等待状态，之后客户端结束，断开了
ps.flush();                                                                                 和服务端的连接，服务端将抛出异常


------------------------------------------------------------------------------------------------------------------------
多发和多收,参考demo代码

整体存在的缺点
1、每个socket接收到，都会创建一个线程，线程的竞争、切换上下文会影响性能
2、每个线程都会占用栈空间和cup资源
3、并不是每个socket都进行io操作，会导致无意义的线程处理
4、客户端并发访问增加时，服务端将呈现1：1的线程开销，访问量越大，系统将发生线程溢出，线程创建失败，最终会被打挂宕机，从而不能对外提供服务


------------------------------------------------------------------------------------------------------------------------
伪异步i/o编程
为解决上述问题，可以采用伪异步io的通信框架，即采用线程池和任务队列来实现，当客户端接入时，将客户端的socket封装成一个Task后交给线程池处理，由于
线程池可以设置任务队列的大小和最大线程数，因此对资源的占用是可控的，无论多少客户端并发访问，都不会导致资源耗尽或者宕机。

注：这种方式仍然有问题，即可以同时处理的客户端请求受限于线程池的最大线程数，只有处理完其中一个请求才能去处理新的请求。
















