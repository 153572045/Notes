TCP(传输控制协议)

相关文章：https://zhuanlan.zhihu.com/p/51559505
        https://blog.csdn.net/qq_30108237/article/details/107057946
        https://juejin.cn/post/6844904063964807182
        https://juejin.cn/post/6844904117471559687

1、建立连接(三次握手)
在进行数据传输前，需要建立一个连接，这个连接其实是一个虚拟连接，通过这个虚拟连接，双方可以知道对方的信息，知道是和谁在建立连接，一个连接可以由一个
四元组来表示，即一对套接字:源IP、源端口号、目标IP和目标端口号。
总的来说，通过三次握手，连接双方可以得知对方的信息，确认了双方都具备接收和发送信息的能力，并且交换了序号，以便进行接下来的第一次数据传输。此外，还
互换了一些控制信息，用于控制后续的交互操作，比如MSS

握手过程：(请求 → 应答 → 应答之应答)
双方的初始状态都为CLOSED,当服务端开始提供服务，即主动监听某个端口，进入LISTEN状态
(1)、客户端发送一个报文，报文的SYN标志位为1，同时携带了初始序列号，之后客户端处于SYN-SENT状态
(2)、服务端收到报文后，发了一个SYN和ACK标志位都为1的报文，同时携带了初始序列号和确认序列号，进入SYN-RCVD状态
(3)、客户端发送一个ACK标志为1的确认报文，携带了确认序列号，之后客户端进入ESTABLISHED状态，服务端收到报文后也转到ESTABLISHED状态，连接建立
若客户端和服务端的初始序号分别为 x,y  则连接后双方的当前序号分别为x+1,y+1，分别作为下一个包的序号

为什么握手是三次
TCP为了保证其消息的可靠性，需要有ACK确认机制，因此，对于每一个SYN包，至少要对应一次确认包，如果减少为两次握手，那么服务端将收不到客户端对其SYN包
的确认，无法确认客户端是否收到其SYN+ACK包，如果增加握手次数，如四次，那么又增加了握手的通信次数，效率会降低，而且，TCP本来为了减少连接建立的通信次
数，就已经将服务端的SYN和ACK进行了合并，所以三次握手的设计比较合理。

握手异常：https://juejin.cn/post/6844904063964807182

2、断开连接

(1)、由某端，比如客户端先发FIN包准备断开连接，也会携带seq, 之后客户端进入FIN-WAIT1状态
(2)、服务端收到FIN包后发送ACK包确认收到，之后进入CLOSED-WAIT状态，之后进行一些断开的准备工作，客户端收到ACK后进入FIN-WAIT2状态
(3)、准备工作做完后服务端会发送一个FIN、ACK包(也会携带确认序号),请求断开连接，状态变为LAST-ACK状态。
(4)、客服端收到包后状态变为TIME-WAIT，之后发送一个ACK包确认，为了安全和稳定，客户端发送ACK包后会维持在TIME-WAIT状态2MSL，最终进入CLOSED状态
服务端收到ACK包后也进入CLOSED状态

标志位：
URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。
ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。
PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。
SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。
FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。

在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS：Maximum Segment Size）。最理想的情况是，最大消
息长度正好是 IP 中不会被分片处理的最大数据长度。

------------------------------------------------------------------------------------------------------------------------
序号（Sequence Number）
指发送报文段的序号，也可以理解为发送数据的位置，这个位置表示的是报文段中数据部分的第一个字节。
序号字段的长度为32位无符号数，数值范围为0~2^32 - 1（即4,294,967,295)，当序号达到最大值时，会重新从0开始递增。
每发送一次数据，序号就累加一次数据字节数的大小。比如本次发送的序号为1，发送的数据大小为4个字节，则下一次发送数据的序号为1+4=5。
序号的主要作用：用于解决网络包的乱序问题。确保接收端能够按照正确的顺序接收并处理包数据

确认序号（Acknowledgement Number）
确认序号的长度为32位无符号数，用于接收端向发送端确认已经接收的数据位置。
发送端在收到这个确认序号之后，可以认为在这个序号之前（确认序号值减去1）的数据都已经被正常接收。
既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。
只有TCP首部Flags中的ACK标志为1时，确认序号字段才有效。
确认序号的主要作用：用来解决不丢包问题。通知接收端已经接收了哪些数据。

初始化序号：随机

------------------------------------------------------------------------------------------------------------------------
关于报文的分片

TCP报文的长度上限是1500 - IP头(20) - TCP头(20) = 1460 (Bytes)     UDP 包的大小应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)
IP报文是65535，但是TCP会对数据进行分片，所以其实到了IP层也是只有1480
以太网的MTU是1500(46-1500)
目前的浅见是：应用层给的数据如果超过TCP的报文上限，那么会被TCP分片到1460，一般是1440(MMS),再交给IP，最后经过以太网以1500+18传出去，所以理论上
TCP传输数据时，以太网是不需要去对数据进行切片，IP更不用
而传输UPD的时候，由于UPD对报文长度没有限制，所以如果超过IP的长度限制，那么切片会在IP层进行，之后到以太网层还需要继续切。


如何解决TCP丢包的问题
TCP协议丢包后，如何解决丢包的问题
为了满足TCP协议不丢包。TCP协议有如下规定：
数据分片：发送端对数据进行分片，接受端要对数据进行重组，由TCP确定分片的大小并控制分片和重组
到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认
超时重发：发送方在发送分片时设置超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片数据
滑动窗口：TCP连接的每一方的接受缓冲空间大小固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致
使较慢主机的缓冲区溢出
失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层;
重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据;
数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验或有差错，TCP将丢弃这个分
片，并不确认收到此报文段导致对端超时并重发

面试问题：TCP怎么保证可靠安全的通信

首先TCP通过序号去保证数据能够被接收方正确处理，不会出现乱序的情况，通过确认序号保证不会丢包，如果发送方没收到确认包的话会进行超时重发，接收方如果收到
重复的包会丢掉。
此外还有数据校验，滑动窗口等一些机制，数据校验可以检查数据在传输的过程中是否有变化，如果有变化该包会被丢弃，滑动窗口则可以控制流量的速度，防止较慢的主
机缓冲区溢出




