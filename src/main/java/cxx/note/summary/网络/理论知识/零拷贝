
前置知识

一、程序要读取硬盘上的文件，具体的步骤如下
1、应用程序调用相关接口
2、程序进程被阻塞，被CUP移出执行队列放到等待队列
3、CUP让DMA去磁盘读取数据到内存
4、DMA读取完毕后去通知CUP，CUP再将之前的阻塞进程从等待队列移到执行队列

二、往网络发送数据
前提：数据已在内存中
1、CUP将内存中的数据读取到本身的高速缓存或寄存器上
2、将数据放到一个socket缓冲区上
3、让DMA从缓冲区拿给网卡

三、内核态和用户态
SYS_API是内核态的一些系统调用的API，我理解只有在内核态才有调用权限
每个进程在内核态都有一个对应的进程描述符，进程描述符内包括了thread_info和内核堆栈
thread_info，就是线程上下文信息，存放CUP临时状态的内容，就是发生线程切换的数据存放在这，内容主要有用户程序基地址，程序计数器，
cup cache，寄存器，用户恢复现场。
内核堆栈(8140byte),用于该进程调用内核态API时，分配变量空间用的。

读取文件的流程
程序调用read函数，这个函数是系统提供给用户进程使用的接口，这个函数会让用户态切换到内核态，具体步骤如下：
1、到cup某个寄存器里面存一个系统调用号(sys_api的标识)。
2、执行80中断指令，这个指令会导致用户态到内核态的切换，首先会将当前进程的cup上下文保存到thread_info中
3、执行相应的sys_api函数(会先检查缓冲有无相应数据，没有再去磁盘读取)
sys_api的读取函数会先将数据读取到内核空间中的一个文件缓冲区，然后再拷贝到用户空间，之后才能被用户程序所使用。
也就是说，想要从磁盘读取数据，数据要先从磁盘到内核缓冲区，之后才拷贝到用户空间，需要两次拷贝

向网络上发送数据时的流程

和上面一样，也是需要系统调用
1、切换到内核态后将数据从用户空间写到套接字缓冲区，若缓冲区满了会阻塞
2、CUP喊DMA从缓冲区拿数据到网卡
3、拿完数据后DMA会发一个中断给CUP，这个中断会让CUP将进程从阻塞队列中拉到运行队列，之后继续发送数据


四、零拷贝
前置：虚拟内存，虚拟内存可以大于物理内存，通过LRU算法把数据先存放在磁盘的swap区域
使用零拷贝的前提，不同虚拟内存可以映射到同一个物理内存

在读取磁盘数据的时候，DMA从磁盘中将数据读取到内核空间的一个文件缓冲区，这个文件缓冲区和用户空间的某个缓冲区的物理内存地址是一致的，这样就不用进行
从内核空间将数据拷贝到用户空间的缓冲区了。


五、传统IO，需要4次拷贝
1、DMA从磁盘拷贝数据到内核空间的内存缓冲区
2、CUP将内存缓冲区中的数据拷贝到用户数据缓冲区
3、CUP将用户数据缓冲区中的数据拷贝到内核空间的socket缓冲区
4、DMA将socket缓冲区中的数据拷贝给网卡

零拷贝的实现方式：两种

mmap(3次拷贝4次用户内核态切换)
1、DMN从磁盘拷贝数据到内核缓冲区
2、该内核缓冲区也是用户缓冲区的共享空间，不需要复制，因此可直接由CUP拷贝到socket缓冲区
3、DMA从socket缓冲区将数据拷贝到网卡

sendfile(3次拷贝2次用户内核态切换)
和mmap相比，直接发起发送命令，所以不需要多切换两次状态


问题
1、单线程处理多个请求的时候，CUP已经在处理某个连接事件，新的请求会被丢弃吗？
不会，新的请求，也就是新的输入会被DMA处理放到socket缓冲区中，之后再由CUP去处理，因此不会丢弃(有待考证)

在linux中，每一个网络连接都是一个文件描述符(Fd),所以在单线程中处理网络连接最基本的形式就是在一个while循环中，不断去遍历各个代表网络连接的
文件描述符 Fd1~Fdn,判断各个文件描述符中是否有数据，有就处理，没有就下一个。















