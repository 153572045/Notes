
Zookeeper基本介绍
Zookeeper是一种分布协调服务，即分布式协调组件

一、应用场景：
1、分布式协调中心： 比如某台服务器上的变量改变了 (int flag=true),其他服务器的状态没有得到同步，就可以通过各个服务器都监听某个znode，一旦某台服务
器的值改变了，就去操作znode，而其他监听该节点的服务器就会受到通知，从而实现同步。 简而言之 zk的watch机制可以保证服务器之间数据的一致性。
2、分布式锁
3、无状态化的实现：比如可以把用户的登录状态放到zk服务器上，这样分布式系统就实现了无状态化
------------------------------------------------------------------------------------------------------------------------
二、配置文件说明：主要保存了 基本时间单位、超时时间、端口号和数据存储位置等参数。
启动命令 ./zkServer.sh start/status 配置文件位置(没配则用默认位置的文件)
客户端启动  ./zkCli.sh
------------------------------------------------------------------------------------------------------------------------
三、基本数据结构znode

(1)包含了四个部分：
1、data:保存数据
2、acl:权限,定义了哪些用户可以进行哪些操作
3、stat:元数据，     包含了 节点的创建事务ID，修改事务ID，创建时间，数据长度，数据版本，子节点个数等信息
4、child:子节点

(2)znode的类型
1、持久节点                 create /test
2、持久序号节点              create -s /test    创建的节点名称后面跟着序号id   （运用场景：分布式锁）
3、临时节点（场景：服务注册与发现）      create -e /test    生命和跟随当前会话一致，会话结束后大概10秒就会删除
                                  原理：zk客户端链接到zk服务器后，服务器会给客户端返回一个会话id(可以在节点的元数据中查看)，该id被客户端保存
                                  只要客户端和服务端有持续的通讯（有Ping的消息发过去）,那么服务端的会话id就会一直被续约，如果会话断开，id不被续约
                                  该客户端创建的临时节点就会被删除。服务端有一个轮询任务去检测哪些会话id过期，过期的则删除
4、临时序号节点              create -e -s /test  (运用场景：临时的分布式锁)
5、Container节点 容器节点   当容器中没任何子节点，会被定期删(60s)  create -c /mycontainer
6、TTL节点    可以指定节点的定时时间 了解即可
------------------------------------------------------------------------------------------------------------------------

四、常用命令：
create /test data   创建一个节点，数据为data,可以不配data即为空节点
create /test data auth:chen:2212322:cdrwa  创建一个有权限限制的节点，具体参考第六点
get /test  获取节点数据
get -s /test  获取节点各种数据
get -w /test  获取节点的数据并对该节点进行监听
delete /test  删除节点  如果节点有子节点，则应该用下面的命令
deleteall /test
delete -v 1 /test   如果节点的数据版本号对得上1 则删除，否则不删除(运用的原理：乐观锁)
ls /test    查询节点，获取子节点信息，只有儿子节点
ls -R /test    递归获取各个子孙节点
ls -w /test  监听节点的目录，若该节点创建了子节点，则会收到通知，到那时内容改变则不会，子节点的子节点则不会触发
ls -R -w /test    监听所有子孙节点
set /test abc  为某个节点赋值，会使该节点的数据版本号加1(节点元数据中的 dataVersion)
------------------------------------------------------------------------------------------------------------------------

五、持久化机制
zk的数据是运行在内存中，提供了两种持久化机制，默认情况下都开启
(1) 事务日志:zk把执行的命令以日志的形式保存在dataLogDir指定路径的文件中(配置文件中的参数，如果没有指定dataLogDir,则按dataDir指定的路径)
(2) 数据快照:zk会在一定时间间隔内做一个内存数据快照，即把该时刻内存中的数据保存到快照文件中。
在进行数据恢复时，zk先恢复快照文件中的数据到内存，然后再用日志中的数据做增量恢复，这样的恢复速度会更快。
------------------------------------------------------------------------------------------------------------------------

六、权限设置
(1)注册用户名和密码,即添加一个权限
addquth digest chen:2212322   给当前的会话注册了一个用户
create /test data auth:chen:2212322:cdrwa  创建一个有权限限制的节点(cdrwa 创建删除可读可写权限设置)，只有当前的会话是该用户才能操作
                                            执行上述add....命令就可以设置当前会话的用户。
------------------------------------------------------------------------------------------------------------------------

七、分布式锁

https://blog.csdn.net/feiying0canglang/article/details/113409146


------------------------------------------------------------------------------------------------------------------------
八、watch(监听)机制

监听的主体是客户端，即zkCli或者Curator,被监听的是节点，即zk服务器内的某节点发生改变，zk服务器就会通知监听的客户端
监听方可以看到节点数据的变化类型  比如NodeDataChanged,具体内容不清楚  删除节点也会被监听到
监听是一次性的，被触发完一次监听，下一次节点变化则不会再收到信息，所以要循环执行get -w /test
普通监听无法监听该节点的子节点状态，比如create一个子节点没法收到信息
[客户端会通过NIO去等待节点的回调，学习]

ls -w /test  监听节点的目录，若该节点创建了子节点，则会收到通知，而内容的改变则不会，子节点的子节点则不会触发
ls -R -w /test    监听所有子孙节点


------------------------------------------------------------------------------------------------------------------------
九、集群
三个角色：
1、Leader 负责数据的读写
2、Follower  负责数据的读  可以参加选举
3、Observer  负责数据的读  不参加选举

ZAB协议(Zookeeper Atomic Broadcast 原子广播)
1、zk集群以一主多从的形式进行部署，为了保证数据的一致性，使用了ZAB协议解决了zk的崩溃恢复和主从数据同步的问题。
2、ZAB协议定义了四种节点状态，分别是 Looking:选举状态; Following:从节点所处的状态; Leading:Leader节点所处的状态; Observing:观察者所处的状态

集群启动的投票：
分为两个阶段：
第一阶段：各节点生成一张自己的选票(n,0),第一次启动事务id为0,然后广播形式传递给彼此,各自从这些选票中投出一张myid最高的选票到自己的投票箱。
第二阶段：彼此再将各自在第一阶段投的票互相传递，投完票后若超过集群数量半数，follower就产生，否则等待下一台服务器的启动再次发起投票
总述：第一次投出自己认为最大的票，第二次把自己投的票告知其他节点。

崩溃恢复的Leader选举
Leader建立完之后，会周期性地不断向各个Follower发送心跳（ping命令，没有内容的socket）,而各个Follower也会周期性去读这个信息，如果Follower发现
socket通道已关闭(读不到信息抛异常),就会进入Looking状态，开始选举，和启动选举一样。

主从数据同步的实现(两阶段提交)

半数以上的目的是提高整个集群写数据的性能 保证了可用性，在可用性和一致性之前做了协调
------------------------------------------------------------------------------------------------------------------------

CAP理论

1、一致性C：指的是更新操作成功，并返回客户端完成后，集群中所有节点的数据一致
2、可用性A：服务一直可用
3、分区容错性P：指的是某台节点故障了，集群仍然能对外提供满足一致性或可用性的服务，分区就是冗余部署，这样的分区就具备了容错性

AP：如果允许在数据同步的过程中对外提供服务，那么追求的是AP

CP：反之追求的是CP

ZK最求的是CP，但是为了保证性能，并没有使用强一致性，而是顺序一致性(事务id单调递增)，这样能实现最终一致性，超过半数节点做好同步准备集群就进行同步操作。
------------------------------------------------------------------------------------------------------------------------
ZK的通讯模式

NIO：1、被客户端连接的2181端口，使用的是NIO和客户端建立连接
     2、watch机制，客户端也是用NIO来监听zk的回调

BIO：集群多个节点的通信，比如投票用的是BIO







