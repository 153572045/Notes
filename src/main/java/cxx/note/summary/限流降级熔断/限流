

限流指的是在高并发、大流量请求的情况下，限制访问系统的流量，从而保证系统的安全。
https://juejin.cn/post/6870396751178629127

常用的限流算法有计数器固定窗口算法、滑动窗口算法、漏斗算法和令牌桶算法，

1、固定时间窗口算法：
在固定的时间窗口内计算请求数，比如1秒内，在请求数还没超过阈值则处理请求，计数器加1，如果超过阈值则拒绝请求，
在下一个时间窗口计数器重置为0。
优点：简单
缺点：没法平滑处理流量，有“突刺现象”，有可能在大部分时间段内让用户感觉到系统不可用
窗口切换左右可能产生两倍阈值的流量

2、滑动时间窗口算法：
解决了固定窗口切换时可能会产生两倍于阈值流量请求的缺点。

3、漏斗算法：
请求来了先放入漏斗，然后以恒定的速率取出漏斗中的请求进行处理，如果超过过漏斗容量则拒绝请求。

优点：可以平滑流量处理
缺点：无法解决突发流量问题
适用场景：一般用来保护下游系统，保证自身的流量平稳的打到第三方的接口上

4、令牌桶算法：
以恒定的速率向桶中放入令牌，直到桶满，请求打过来的时候先去令牌桶内拿令牌，拿到则处理，否则拒绝。

特点：令牌桶算法是对漏桶算法的一种改进，除了能够在限制调用的平均速率的同时还允许一定程度的流量突发
令牌桶算法一般用于保护自身的系统


odin的限流策略

使用了google的RateLimiter(限流器)

大致的思路是
有两个任务  正常的task 和 一个限流时触发的fallback，返回结果都是一个CompleteFuture<broadwayReply>,只不过后者是个空壳

1、检查限流开关  如果关闭则直接运行任务task
限流开关可以通过zk打开(获取限流配置的zk节点)，也可以在单机的代码里强制打开
2、如果开关打开
则获取该推荐位需要的令牌数量
3、调用RateLimiter.tryAcquire方法，该方法还有一个等待时间
如果返回true则调用task,否则fallback

各集群的限流
"master"：50
"qrqm2"：10
"smart"：10




