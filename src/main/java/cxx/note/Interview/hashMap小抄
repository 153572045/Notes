
1、创建一个hashMap
HashMap<String, String> map = new HashMap<>();
可以指定初始容量和负载因子，如果没指定，就使用默认容量16和默认负载因子0.75
不会初始化table,仅仅给负载因子赋值，而容量的值赋给了阈值，因为并没有capacity属性，而此时的table还没初始化，所以暂时赋给threshold

2、table的初始化发生在第一次put方法上
第一次put先用threshold初始化table，如果不是2的n次幂，则转为大于threshold的最小2的n次幂  如threshold=12 则table的length=16

put方法：
(1)计算出key的hashcode,在原生的hash方法上加一些位计算进行扰动，减少hash冲突
(2)计算在table中的位置，逻辑上是取模，计算时用与(&)运算进行优化
(3)检查该桶位置上是否存在相同的key，有的话就覆盖
(4)没有的话就将新的Entry插入
插入后会检查扩容，1.8版本的应该是插入前检查扩容
(5)扩容resize方法
new一个容量两倍的新table再调用transfer方法将数据迁移到新table
transfer的逻辑大概如下：
遍历table各个元素(桶)
再遍历每个元素的链表，用头插法插入到新的table上
因为用的头插法，所有在并发环境下，扩容时可能会导致元素相互引用，产生循环链表，因此在调用get方法的时候会发生死循环，引起CUP100%的问题
而且还存在数据丢失问题

hashMap1.8

改进点
1、使用尾插法替代1.7的头插法，避免了死循环的问题，但是有可能会导致数据丢失，也不是线程安全的
2、在扩容遍历到某个链表的时候，将链表中的元素的hash值和旧容量做一个位(&)运算，分为上半部和下半部两类，上半部的元素插入新数组的位置和旧数组
的位置一样，下半部是旧数组下标加上旧容量。 这样减少了计算量。
3、加入红黑树  当一个桶的元素大于8时改用红黑树存储，小于等于6时退化为链表

tableSizeFor方法
保证了输入值从次高位开始都为1，然后再加1就得到一个不小于输入值的2的n次幂的值


concurentHashMap 1.8

不允许使用空值

2、sizeCtl含义
sizeCtl = 0时，表示数组未初始化，且数组的初始化容量为16
sizeCtl 为正数时，如果数组未初始化，则记录的是数组的初始容量，如果已经初始化，则记录的是扩容阈值
sizeCtl 为-1时，表示数组正在进行初始化
sizeCtl 为非-1的其他负数时，表示数组正在扩容，-(1 + n)表示此时有n个线程正在共同完成扩容操作

3、put方法的逻辑：

(1)、如果table为空，调用initTable方法初始化数组
(2)、计算新元素的位置，如果该位置为空，则用CAS直接插入
(3)、不为空就用synchronized锁住该位置的第一个元素，用尾插法插入    (注)若该位置第一个位置的hash为-1，则说明目前正在扩容迁移数据，当前线程会协助扩容
(4)、调用addCount方法维护map的元素数量，同时检查扩容
addCount解析：
baseCount   基本数量
CounterCell[] counterCells 若存在竞争，有些数量会存放到这
1、如果没有竞争的情况下，counterCells == null,直接用CAS修改baseCount就行
2、存在竞争，即1中的CAS失败或者counterCells不为null,则调用fullAddCount函数去维护一个counterCells数组
fullAddCount解析：
1、初始化一个线程的随机id,类似hashcode
2、如果counterCells还未初始化，则以2为大小进行初始化
3、如果初始化完成，那么用这个随机Id找到在数组中的位置，用CAS去增加这个位置counterCell的数量，如果还没初始化就先new一个counterCell

在用CAS增加counterCell的value的时候，如果CAS失败，会判断counterCells是否需要扩容，即数量是否大于CUP核数，如果小的话会去扩容，大的话不扩
容继续自旋。

二、扩容逻辑
目前只了解了大概，之后还需加强巩固
在多线程环境下，会出现多个线程分别负责一条链表的迁移
1、遍历旧数组，对各个位置上的链表分别进行数据迁移，迁移之前会用synchronized锁上
2、优化点，在迁移的时候可以将元素分为两类，就是在低位或者高位，在迁移某个链表的时候，会先遍历一下链表，找到同类的最后位置lastRun，之后遍历做迁移的时
候一个一个元素挂到新的数组上，知道遇到lastRun就可以整个挂上去，在很多情况下可以降低计算量
