

微服务(Microservices) 是一种软件架构风格，它是以单一责任功能的小型功能区块为基础，利用模组化的方式组合出
复杂的大型应用程序，各功能区块使用与语言无关的API集相互通讯。
优势：
1、微服务最大的一个有点就是比传统的应用程序更有效地利用计算资源，这样的话，开发人员只要为额外的组件部署计算资源。
2、除此之外，微服务更快，并且也很容易更新维护。

1、推荐引擎是什么
是整个推荐系统的一个业务逻辑引擎，推荐系统的入口服务，一个请求打过来，我们就会通过调用其他服务来实现推荐业务，最终返回推荐商品。

我先简述下我们这的一个基本的推荐流程， 推荐的第一个阶段是 1、取数，也就获取用户画像和用户行为2、之后就是召回，就是从一个或多个
商品底池中根据用户数据捞取一部分商品 3、接着是排序，将召回阶段获取到的商品进行排序 4、最后是过滤和截断，然后将数据推出去。 这
是一个基本的推荐流程，大致有四，五个阶段

我们的系统是将画像取数，召回，排序，和过滤等推荐环节串起来的一个逻辑调度系统，首先我们会去调用画像服务，从那边拿到用户的数据，然后再将这些数据作为输入
去调用召回服务，召回服务就会给我们返回商品数据，再将返回的商品数据作为输入去调用排序服务，排序服务就会对我们的商品做一个排序再返回给我们
，最后我们再对这些数据做一系列过滤和截断，然后返回给我们的上游服务。其实大致可以理解为是一个数据的枢纽站，控制着整个推荐系统的数据流，
是一个IO密集型的系统。

2、树引擎是什么

我们将一次请求的执行逻辑(一个推荐逻辑调度)用一棵树来描述，这棵树是用hocon数据格式描绘在一个config配置文件中的，每个推荐位的推荐逻辑不同，对应着不同
的树配置文件。当一个请求打到我们系统的时候，我们会根据请求中的pid（推荐位id）去获取一个对应的树配置文件，这个文件是我们提前配置好的本地文件，然后我们
代码会将这个配置文件解析成一个config对象(TypesafeConfig,一个包)，然后代码中的调度模块会根据这个config去执行逻辑。
其实一个config对象是对一个树节点配置的描述，而树是一种递归结构，所以对根节点的描述其实就可以递归描述到整颗树的各个节点

树中的节点分为业务节点和调度节点两种类型，业务节点对应着具体的业务对象，而调度节点起到对这些业务节点的编排作用，比如说两种最常用的调度节点是并行节点和串
行节点，我们的代码会从树的根节点开始解析，当解析到的节点是串行节点的时候，就会以串行的方式去执行这个调度节点的子节点，当解析到一个并行节点的时候，就会以
并行的方式去执行它的子节点，解析到一个业务节点的时候，就会去执行这个业务节点的业务方法。
具体执行业务节点的时候，会将config对象中的数据用反射注入到具体的业务对象中，这样可以起到配置化开发的效果，即提高代码的复用效率和整体的迭代效率

然后关于业务节点的数据传递问题，我们每个业务节点执行后的数据会存到一个上下文的对象中，也可以直接传递给后续节点，因此每一个节点都可以从这个上下文对象
中去获取一些前置的依赖数据，比如说召回对象可以从这个上下文对象中获取用户画像数据，排序对象可以从这个上下文对象中获取召回商品数据

优点：树调度引擎让我们可以去编排各个业务节点的调度顺序和调度形式，哪些节点可以并发执行，哪些节点因为具有依赖关系只能串行调度，在没有业务逻辑改变的
情况下，这些只需要改变配置文件的配置就可以进行调整。
缺点：因为我们不同的推荐位的复杂程度不一样，当推荐位比较复杂的时候，一棵树的节点会有上百个，人工编排节点的工作量就会变得比较大，而且出错的可能性会比较
大，比如说有些节点可以并发执行，但是你配置成串行执行了，这样虽然结果不会改变但是影响了并发效率。甚至有些节点因为具有数据依赖关系应该串行执行被你配置成
并行执行，那么结果就会出问题。因此我们将调度引擎升级到图引擎

3、图引擎是什么
将手动编排节点执行顺序的方式转换成为数据依赖驱动的执行方式，在图引擎中所有节点都是业务节点，没有调度节点，每个节点只需要关心自己依赖的数据和产出的数据，
我们的代码也是会去解析hocon配置文件然后产生一个图对象，构建图对象的过程中会根据文件的配置信息确立各个节点之间的依赖关系，并在运行过程中，让数据依赖就
绪的节点尽早运行，达到无需我们手动调整，就可以实现自动化最优并发执行的效果。
它的实现大概就是说，先从图的出口节点，也就是最终节点处从后往前进行遍历，这个过程会去获取各个节点的依赖关系并记录到一些map中，这个过程也称为激活，激活
完后从图的入口节点，也就是第一个节点开始运行，第一个节点的依赖数据其实就是一个请求，我们系统接到一个请求时会把这份数据送到第一个节点，那么它的依赖数据
就绪了，就可以直接运行了， 节点运行完后会产出数据，这个时候它们会去搜索激活阶段的依赖关系，找到依赖于这个产出数据的节点，然后把它的依赖数量做减一操作，
如果减一操作后该节点的依赖数为0，那么直接将该节点放到线程池中运行，这样就实现了依赖数据就绪的节点可以立即执行。

5、算子重构
因为将一些推荐位从旧架构迁移到新架构不是简单地把代码复制过去，需要根据逻辑去进行重构，所以在迁移早期，为了加快项目的进展，一些人将一些通用模块以写死的
方式去实现，或者说那个时候考虑得不周全，产生了一些冗余代码，就是说各自开发各自的东西，也不考虑复用性，所以我就去对这类代码重新进行抽象和重构，主要负责的
模块是一些取数模块和召回模块。


6、你们的系统是如何做到高可用高并发的

首先从高可用这一块来讲吧，在架构的设计上，我们几乎所有业务算子，就是业务类都是继承自同一个接口，同一个抽象类，就是说根据自己负责的功能去实现这个抽象
方法，然后这个方法被顶层抽象类中另一个方法所调用，调用的外层加了一层try/catch结构，catch根据不同类型的业务类会返回一些默认值，这一点尽可能减少了
整条数据链路因为某个业务类有bug抛出异常，导致整条链路出不了数据的情况。当然，因为我们系统的特点，在一些重要节点如果拿不到数据或者出现异常，也会最终
出不了结果，比如说在召回阶段，有可能网络超时原因或者那边服务不可用的原因导致我们这边拿不到数据，所以我们每次推荐都会用多个算子去调用多路召回服务，
即使其中某路出了问题，也有一些冷启的召回进行兜底，不会说出现空结果。
在比较高峰的时候，我们会做一些降级处理，比如说降低模型的复杂度，减少召回数量等一些降级措施，即使因为某个环节出问题最终出不了结果，我们的上游服务会给我
们做若个性化的兜底，他们再出不了的话前端那边会做一些缓存兜底。
当然到了最后还是需要做限流

高并发这一块，因为我们有两套架构嘛，旧的树引擎，还有新架构图引擎，之前使用树引擎我们可以手动去编排各个节点的执行顺序和执行方式，一些彼此之间没有数据
依赖关系的节点可以采用并发的方式去执行，有依赖关系的节点就采用串行执行，当然毕竟是需要手工去控制，在一些复杂推荐位中这些树节点有上百个，编排起来还是比
较麻烦，也有可能出错，所以在图引擎换成了以数据依赖驱动的方式去执行，每个图节点仅关注自己的依赖数据和产出数据，如果某个节点的依赖数据就绪，那么它可以立刻
被丢入线程池执行，若它执行完毕后产出数据，就会去激活依赖于它的节点，让下一个节点立即去执行。这样可以达到无需我们手动调整，就可以实现自动化最优并发执行
的效果。


