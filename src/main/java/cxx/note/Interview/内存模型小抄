java内存模型概述：

java线程是运行在自身的工作内存之上，不与主内存直接进行交互，可以类比于物理机的高速缓存和主存之间的关系，目的是为了提高运行效率，解决CUP计算速度和
内存读写速度之间的矛盾，因此线程之间的数据传输只能通过主存作为媒介以共享变量的形式来进行。
java内存模型定义了主内存和工作内存之间的一些交互协议，比如有8种原子操作以及它们之间的一些限定规则，还有对各种变量访问规则的定义，比如具有特殊访问规
则的volatile变量

------------------------------------------------------------------------------------------------------------------------
然后既然各个线程都工作在自己的工作内存之内，那么线程间就会出现缓存不一致的问题，java是用volatile变量来解决这个问题，
volatile也是虚拟机提供的一种最轻量级的同步机制，主要解决了可见性和禁止指令重排问题，在代码层面，它表现为会在volatile变量的赋值操作后面插入一条以Lock为
前缀的字节码指令，这条指令会形成一个屏障，使得指令无法越过这个屏障进行重排，其实这个指令更进一步解析，它可能会翻译成store和write这两个原子操作，就是
说执行引擎对工作线程中一个volatile变量副本进行assign操作后，会立即执行store和write这两个操作，将最新值刷回主存，同时使得其他线程中对该变量的缓存无效，
另一方面，在use之前会执行read和load这两个操作获取当前内存中的最新值，这些访问规则保证了共享变量的可见性，然后因为在执行store和write这两个操作的时
候，必须保证之前的指令都执行完毕，因此也就产生了指令重排无法越过屏障的效果。还有一个就是虽然volatile可以保证可见性，但是由于Java的运算不是原子性的，因此还
是有可能会出现线程安全问题。

平时我们可以用先行发生原则来判断在java内存模型中一些代码是否安全
若A先行发生于B，那么A的操作对于B来讲是可以观察到的
若不存在天然的先行发生关系，那么顺序性则无法得到保证，虚拟机可以按任意顺序进行执行

1、程序次序规则：在同一个线程内，代码按照控制流的顺序执行
2、管程锁定规则：解锁操作先行发生于后面的加锁操作（对同一个锁）。
3、volatile变量规则：volatile变量的写操作先行发生于后面对这个变量的读操作
4、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测
6、对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
7、传递性规则：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论