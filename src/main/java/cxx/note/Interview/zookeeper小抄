
Zookeeper基本介绍
Zookeeper是一种分布协调服务，即分布式协调组件

一、应用场景：
1、分布式协调中心： 比如某台服务器上的变量改变了 (int flag=true),其他服务器的状态没有得到同步，就可以通过各个服务器都监听某个znode，一旦某台服务
器的值改变了，就去操作znode，而其他监听该节点的服务器就会受到通知，从而实现同步。 简而言之 zk的watch机制可以保证服务器之间数据的一致性。
2、分布式锁
3、无状态化的实现：比如可以把用户的登录状态放到zk服务器上，这样分布式系统就实现了无状态化

------------------------------------------------------------------------------------------------------------------------

五、持久化机制
zk的数据是运行在内存中，提供了两种持久化机制，默认情况下都开启
(1) 事务日志:zk把执行的命令以日志的形式保存在dataLogDir指定路径的文件中(配置文件中的参数，如果没有指定dataLogDir,则按dataDir指定的路径)
(2) 数据快照:zk会在一定时间间隔内做一个内存数据快照，即把该时刻内存中的数据保存到快照文件中。
在进行数据恢复时，zk先恢复快照文件中的数据到内存，然后再用日志中的数据做增量恢复，这样的恢复速度会更快。


------------------------------------------------------------------------------------------------------------------------
九、集群
三个角色：
1、Leader 负责数据的读写
2、Follower  负责数据的读  可以参加选举
3、Observer  负责数据的读  不参加选举

ZAB协议(Zookeeper Atomic Broadcast 原子广播)
1、zk集群以一主多从的形式进行部署，为了保证数据的一致性，使用了ZAB协议解决了zk的崩溃恢复和主从数据同步的问题。
2、ZAB协议定义了四种节点状态，分别是 Looking:选举状态; Following:从节点所处的状态; Leading:Leader节点所处的状态; Observing:观察者所处的状态

集群启动的投票：
分为两个阶段：
第一阶段：各节点生成一张自己的选票(n,0),第一次启动事务id为0,然后广播形式传递给彼此,各自从这些选票中投出一张myid最高的选票到自己的投票箱。
第二阶段：彼此再将各自在第一阶段投的票互相传递，投完票后若超过集群数量半数，follower就产生，否则等待下一台服务器的启动再次发起投票
总述：第一次投出自己认为最大的票，第二次把自己投的票告知其他节点。

崩溃恢复的Leader选举
Leader建立完之后，会周期性地不断向各个Follower发送心跳（ping命令，没有内容的socket）,而各个Follower也会周期性去读这个信息，如果Follower发现
socket通道已关闭(读不到信息抛异常),就会进入Looking状态，开始选举，和启动选举一样。

主从数据同步的实现(两阶段提交)

半数以上的目的是提高整个集群写数据的性能 保证了可用性，在可用性和一致性之前做了协调








