
事务：代表一个完整的业务逻辑，由一个有限的数据库操作序列构成，这些操作要么全部执行成功，要么全部不执行(只有DML语句才和有关  其他都没关系)

实现原理：innoDB引擎提供了一组用来记录事务性活动的日志文件
事务开启后，所有DML语句都会被记录到日志文件中，之后我们可以提交，也可以回滚(在这期间只是对本地内存中的数据做修改)
提交事务后将数据全部持久化到数据库表中，日志文件的事务性活动也被清除了  提交事务标志着事务的成功结束
回滚也会清空事务性活动日志，但是会将之前的DML操作全部撤销，回滚事务标志着事务的失败结束

mysql在默认的情况下，事务是自动提交的，也就是说执行一条语句就提交一次
不自动提交则需要执行命令  start transaction（关闭自动提交事务）
start transaction后  执行命令未提交，在本地也能查到，回滚后就查不到了。

事务的特性
ACID
原子性：指事务中的语句要么全执行，要么全不执行，就是说事务是一个最小的工作单元，是一个完整的业务逻辑。
持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log
隔离性：保证事务执行尽可能不受其他事务干扰；InnoDB默认的隔离级别是可重复读
一致性：指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。


四种隔离级别

1、Read Uncommitted（读取未提交内容）：因为未提交就能被读取到，所以可能出现脏读
命令：set session transaction isolation level read uncommitted;
2、Read Committed（读取提交内容）  大部分数据库的默认隔离级别，问题是不可重复读
set session transaction isolation level read committed;
3、Repeatable Read（可重读）  会出现幻读
set session transaction isolation level repeatable read
4、Serializable（可串行化）  所有指令串行执行，最安全但是效率太低了
set session transaction isolation level serializable
------------------------------------------------------------------------------------------------------------------------
索引
https://juejin.cn/post/6844904115353436174   优化

B树
B树解决了平衡二叉树的高度过高问题，B树是N叉树(节点最大数量叫阶)，每个节点可以存放多个元素，因此存放相同数据量的情况下，高度会比普通二叉树低很多，
可以大大减少磁盘的IO次数，B树的每一个节点称为页，mysql读取的基本单元是页，也就是磁盘块
结构特点：以三叉树为例
节点有三个指针，左指针指向块的元素都小于当前节点的最小元素值，中间的指针指向介于当前节点元素值之间的块，右边指针指向大于当前节点最大元素值
缺点：只能做到高效的单点查询，对范围查找效率低，需要中序遍历

B+树
是B树的升级版本，非叶子节点不存储数据，只作索引，叶子节点存储数据，且用双向链表连接起来，树节点做了冗余，相比于B树既能支持高效的区间查询，插入
和删除都比B树更加出色(直接从叶子节点删除就行)
而且非叶子节点不存储数据，一个磁盘块可以存储更多的元素，整体的高度比B树矮

聚簇索引的叶子节点存的是行数据，非聚簇索引存储的是主键ID，对非聚簇索引的查找需要使用主键ID去聚簇索引上找到真正的行数据，这个过程称之为回表查询。

覆盖索引：所要查询的字段值包含在一个联合索引中，那么就称为覆盖索引，覆盖索引不需要回表查询
myisam只有非聚簇索引，也就是辅助索引，而且叶子节点存储的是行数据的地址，而不是主键id,因此不需要回表查询，但是会多进行一次磁盘IO
https://zhuanlan.zhihu.com/p/364642137

聚簇索引和非聚簇索引：https://blog.csdn.net/yaxuan88521/article/details/125464584
------------------------------------------------------------------------------------------------------------------------
存储引擎：指的是表组织数据的方式，可以在创建表的时候指定不同的存储引擎
InnoDB:支持事务、崩溃恢复，安全性高。
支持数据库奔溃后自动恢复
相对于Myism  不能很好节省空间，不能压缩数据
支持行级锁
每个innoDB表在数据库目录中以.frm格式文件表示
innoDB 表空间tablespace被用于存储表的内容(表空间是一个逻辑名称，表空间存储数据+索引,.frm文件用来存储表的格式)
页是InnoDB管理数据库的最小磁盘单位(默认16kb)，聚簇索引和其他的二级索引都是以B+树的形式保存到表空间的，而B+树的节点就是数据页.
InnoDB引擎以页作为磁盘和内存交互的基本单位

表空间可以对应文件系统上一个或多个真实文件(.ibd文件)，每一个表空间可以被划分为很多个页，表数据就存放在某个表空间下的某些页中
Innodb的表有两个文件: - tableName.frm：表结构文件 - tableName.ibd：索引和数据文件（InnoDB Data）

https://www.jianshu.com/p/ec3b4d1319ca

MyISAM
特点：由三个文件去存储一个表
1、格式文件，存储表的格式(.frm)   desc 表名 的内容就存在这个文件中
2、数据文件，存储表中数据(.MYD)
3、索引文件，存储表上索引(.MYI)
可被转换为压缩、只读表来节省空间

------------------------------------------------------------------------------------------------------------------------
优化

为什么不要用星号查询
1、如果采用select*进行查找时，查询到的列是按照它们在表的原始位置展示的；如果客户端同样采用列的原始位置进行引用，如果更改表结构，会导致难以察觉的错误；
2、使用*时，数据库会先查数据字典，明确*代表什么，这会在分析阶段造成大量开销；
3、select*最大的问题是可能会多出一些不用的列，导致无法使用索引覆盖，导致查询成本几何层级的增加
4、返回不需要的字段会增加数据传输的时间
5、如果查询的时候获取了不必要的列，字段较多时，mysql 并非一次性保存，而是主次分布内存，当时用完后，再次分配。如此会导致多次分配，频繁分配会增加额外消耗时间
6、如果 sql 语句复杂，select*会解析更多的对象，字段，权限，属性等内容，增加数据库负担

一般来讲，一个mysql数据库存放300到500万的数据，再多就严重影响性能(有待考证)


常见的索引优化手段有哪些？
①尽可能的使用复合索引而不是索引的组合；
②创建索引尽量让辅助索引进行索引覆盖 而不是回表；
③在可以使用主键id的表中，尽量使用自增主键id，这样可以避免页分裂；
④查询的时候尽量不要使用select * ，这样可以避免大量的回表；
⑤尽量少使用子查询，能使用外连接就使用外连接，这样可以避免产生笛卡尔集；
⑥能使用短索引就是用短索引，这样可以在非叶子节点存储更多的索引列降低树的层高，并且减少空间的开销；
------------------------------------------------------------------------------------------------------------------------
分库分表
主要是解决数据量过大而导致性能降低的问题，将原有的数据拆分到若干个数据库或若干个表中，使得单一数据库或单一表的数据量足够小，从而保证性能。
一、垂直拆分:由大表拆成小表，以列的维度进行拆分
分库：将不同表放在不同的数据库中，比如商品放在一个库，订单放在另一个库等
拆分方式
1、按照业务进行拆分，将用于不同业务场景的字段垂直拆到不同的表中进行存储。
2、也可以将一个大表按照常用和非常用字段进行拆分，然后使用主键关联
好处：
1、使得单条记录的数据量变小，一个页可以存储更多的记录数，减少磁盘IO
2、按照业务拆分的话，拆分后的业务比较清晰
3、维护比较简单，特别是分库的话不同的业务数据放在不同的机器上
缺点：
1、如果单表的数据量大，读写的压力依然很大
2、主键冗余(也有可能其他列出现数据冗余，就会存在数据一致性问题)
3、对于分表的话会引起表连接Join操作，增加开销。对于分库的话可能还无法join操作，只能通过Java程序的接口去调用，增加了开发的复杂度
4、事务处理更加复杂，需要做分布式事务

二、水平拆分：以行为维度进行拆分，拆分后每个表的结构一样
拆分的方式---核心点：保证拆分后数据能均衡地落在不同的表
1、哈希取模
2、根据具体的数据特点定制拆分规则

好处：
1、单库或单表的数据量降低了，读写效率提升了
2、读写操作可以在不同库或表上进行，因此提高了系统的稳定性和负载能力
3、相对于垂直拆分，因为表的结构和拆分前一致，因此程序改造较少

缺点：
1、数据的扩容难度较大，维护难度大(之前的映射规则可能要打破了，即要迁移数据，又要改造代码)
2、拆分规则比较难抽象，可能设计到后面的扩容
3、跨节点的Join性能差，只能通过java程序接口去调用，逻辑复杂
4、分片事务一致性难以解决(可能需要分布式事务解决？)

总结：垂直拆分比较适合系统建立初期进行的，而水平拆分一般是在系统后期改造进行的

具体实现：现有的开源框架
jdbc直连层：shardingsphere, tdd1
------------------------------------------------------------------------------------------------------------------------
分布式事务

实现方式：
1、2PC(两阶段提交)
2、TCC(Try-Confirm-Cancel)  也是两阶段提交思想
3、本地消息表
4、可靠消息最终一致方案
5、最大努力通知方案

跨库的分布式事务(2PC)  ---atomikos开源框架是这类原理的实现
需要引入一个中间协调者，事务管理器
第一个阶段进行预提交，即在不同库开始事务后执行sql语句(会锁住相关行数据)
第二个阶段事务管理器根据第一个阶段的结果，如果全部成功则都做commit操作，否则进行回滚
如果第二个阶段有提交失败的，则可以用重试机制去解决，重试后还是不行，则记录日志，后续人工解决或用一些补偿脚本去解决

微服务/跨服务的分布式事务(TCC)---引入中间状态
第一阶段：预留资源(Try)，(比如冻结库存，具体实现可以在数据表增加一个字段，执行try的时候冻结库存变1，confirm或cancel则清0)
也就是说每个服务都需要提供一个Try阶段的API，引入中间状态
第二阶段：根据第一阶段的结果，执行资源确认，即执行confirm或cancel
每个服务也需要实现两个API，confirm和cancel的对应API

tcc-transaction开源框架

分布式主键生成方式
1、redis生成  单线程特点
2、zk生成



