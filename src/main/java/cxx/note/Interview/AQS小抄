
AQS(抽象队列同步器)
AQS实现了同步器所需要的一些基本功能，比如自定义标准同步状态，FIFO同步队列等，使用AQS可以极大减少开发同步器的工作
术语：  1、获取同步状态，释放同步状态
-------------------------------------------------------------------------------------------------------------
核心思想：
如果线程请求共享资源，根据state判断资源是否可用，如果可用则将该线程设置为有效的工作线程，然后更改state的值进行锁定，之后如果有其他
线程也来请求该共享资源,发现同步状态不可用，该线程先被抽象成一个Node节点，然后加入一个FIFO队列进行等待，等待持有锁的线程释放锁，恢复
state的时候就会去唤醒FIFO队列中的第一个有效线程。
-------------------------------------------------------------------------------------------------------------

在实现上，AQS内部有三个比较核心的构成，一个是一个int类型的属性state，表示同步状态，还有acquire和release两个方法， acquire方法的功
能是去获取同步状态，它内部会调用一个抽象方法tryacquire，这个tryacquire方法在AQS的子类中实现，以ReentrantLock为例，tryacquire
会去判断state是否可用，即是否为0，如果是的话用CAS修改成1并将当前线程改成AQS的工作线程，如果这个过程成功，那么返回true，否则返回false,
如果tryacquire返回true，那么外围方法acquire会直接返回，之后线程可以去执行同步代码，如果失败，acquire方法会调用其他方法，给当前线程构建
一个node节点插入到同步队列中，之后进行阻塞。 而release方法的功能是释放同步状态，内部也会调用一个抽象方法tryRelease，也是由子类去实现的，
同样以ReentrantLock为例，如果tryRelease方法释放成功则返回true，之后会去唤醒同步队列中的第一个有效线程，如果返回false，则直接退出什么也不做，
这里成功与否取决于state状态是否恢复到0,而且在释放成功的时候，唤醒其他线程之前会先检查一下当前是否存在竞争，就是说这个同步队列是否存在，或者当前节
点的waitstatus是否为-1。

公平锁和非公平锁的区别在于：
1、非公平锁的lock()方法，会先进行CAS操作去获取同步状态，失败了再调用acquire()方法，而公平锁是直接调用acquire()方法，因此非公平锁存在插队情况，
当持有同步状态的线程执行release后，还没来得及去调用unparkSuccessor()方法唤醒同步队列中的线程时，可能被新来的线程插队。
2、另外tryAcquire()方法有点小区别，公平锁的tryAcquire方法中会调用hasQueuedPredecessors()方法检查同步队列是否为空或者当前线程是否为同步队列
的head节点的下一个节点，如果都不是则获取失败。

关于Condition
condition是AQS的一个内部类，所以它可以访问AQS的方法，condition有三个比较重要的构成
1、等待队列：每个condition对象都有一个等待队列
2、等待 await
3、通知 signal
当持有锁的线程在临界区内因为各种原因无法继续执行代码，需要让出锁，它可以调用某个条件变量的await方法，这个await方法的大概逻辑是这样子：
给当前线程构造一个新的Node并尾插到condition的等待队列中，然后释放掉所有state并返回进行保存，之后会唤醒AQS同步队列中的线程，然后自己
进行阻塞，之后当被其他线程调用signal或signalAll方法的时候，这个线程之前构建的那个node节点会从这个condition中的等待队列移到AQS
的同步队列中去，等待最终获得锁。

-------------------------------------------------------------------------------------------------------------







