数据库的存储可分为行式数据库和列式数据库
1、行式数据库
把每一行作为一份数据结构去存储，特点是进行 selete * from users where id = 3 的操作会比较快，而
进行selete avg(age) from users等操作会比较慢
2、列式数据库
把每一列作为一份数据结构去存储，特点和行式相反，具体使用哪种看场景。

Redis:打破了传统的关系型数据库--以业务逻辑为依据进行存储，针对不同数据结构的类型，改变以性能为最优先的存储方式

安装步骤：
下载地址：https://redis.io/download/    redis只有linux版本和macOs版本
1、安装redis之前要先安装c语言的编译环境，如gcc，安装命令yum install gcc   安装完成后输入 gcc --version检查是否安装成功。
2、解压下载的redis压缩包，在目录下执行命令： tar -zxvf redis-6.2.1.tar.gz
3、在解压后的目录下执行指令  make 编译成C文件 （如果该过程报错  可以试试执行 make distclean清除编译文件）
4、再执行 make install 完成安装

Redis的启动：
在上述安装之后，redis在/usr/local/bin目录下
目录内有redis-server和redis-cli两个主要文件，一个是启动服务端启动文件  一个是客户端启动文件
启动方式用后台启动方式（前台启动方式不方便），进入redis的安装目录中，我放在/opt目录下，目录内有一个redis.conf配置文件，
可以把该目录复制到其他目录，如/etc目录中  执行命令：cp redis.conf /etc/redis.conf
把该配置文件中的daemonize改成yes，改完后在bin目录下执行命令： redis-server /etc/redis.conf  完成后台启动
ps -ef | grep redis 命令可以查看redis进程

Redis退出
执行命令 redis-cli shutdown 或 kill杀死进程


Redis的基本使用和相关知识（默认端口6379）
特性：单线程+多路IO复用技术------需深入了解

Redis默认有16个数据库，一般只使用0号库，指令selete n  切换到第n个数据库。


Redis基本用法

String类型的操作和一些基本命令
keys *  查看库中所有key
set k v   设置key=k value=v，若k存在 则进行覆盖
setnx k v  只有k不存在的时候才会设置
mset k1 v1 k2 v2 k3 v3  设置多个kv对
mget k1 k2 k3  获取多个value
msetnx 和上述同理，已存在的K不生效，原子性，只要有一个不成功，则全部失败
setex k 10 v  加上过期时间设置值
setrange name n abc  范围设置，在第n个位置设置abc
get k   获取值
getrange k 0 3  范围获取，获取从0到3的值，上下限都包含  比如有“abcdef” geterange k 0 3返回abcd
getset k v 返回原值并将原值设置为新值v
selete n 切换到第n个数据库
exists k  查询k是否存在
type k  查看key是什么类型
strlen key 获取String值的长度
del key 删除指定key数据（直接删除）
unlink key 同上（非阻塞删除，仅将key从keyspace元数据中删除，真正删除会在后续异步操作）
expire key 10  设置key的过期时间，单位是秒
ttl k  查看k还有多少时间过期，-1永不过期，-2已经过期
dbsize 查看当前数据库的key数量
flushdb 清除当前库
flushall 清除所有库内容
对value进行增加或减少：
incr key
decr key
incrby key 10  可以设置步长
append k value  字符串的value，该命令将value追加到原有的值上

--------------------------------------------------------------------------------------------------------

字符串，String是Redis最基本的类型，String类型是二进制安全的，意味着可以包含任何数据，比如jpg图片，视频或者序列化的对象，只要能转成字符
串的数据都能存储，一个redis中字符串的value最多可以是512M
String的数据结构为简单动态字符串,就是可以修改字符串的值内部结构类似java的ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配，比如一个字符
串的空间为capacity，实际长度是len,capacity>len,当len达到一定长度时会扩容capacity，当len小于1M时，扩容的方式是capacity*2,如果超过1M，则
扩容一次的方式是capacity+1M,最长可以扩容到512M

--------------------------------------------------------------------------------------------------------
列表类型（List）----单建多值
简单的字符串列表，按插入排序，底层数据结构是双向链表，对两端的操作性能高，当使用下标操作中间节点性能差。因此链表查询效率较低
常用命令：
lpush k v1 v2 v3  从左边加入多个值，类似入栈
lrange k1 0 -1  从左边根据下标取值，-1表示之后所有，上述输入后输出结果为  v3 v2 v1
rpush 从右边插入多个值
lpop/rpop k  从左边/右边吐出一个值，出栈，值在键在，没值键亡。
rpoplpush k1 k2 从k1列表出栈一个值并入栈到k2左边。
lindex k index 根据索引（index）取出以k为键的值（从左到右，下标从0开始）。
llen k 返回长度
linsert k before/after value newvalue 在value前面/后面插入值newvalue
lrem k n value 从左边删除n个value(从左到右)  比如 k1  a b c a d e a   执行lrem k1 2 a 结果变成 b c d e a
lset k index value 将k下标为index的值设置为value

数据结构：quickList 快速列表
在列表元素较少的情况下会用一块连续的内存块来存储数据，这个内存块叫压缩列表(ziplist),ziplist里面的元素紧挨着,当数据多时，再
用指针把多块ziplist串起来，这样比普通链表节省了一些存放指针的空间。
即满足了快速插入和删除的性能，又不会出现太大的空间冗余
--------------------------------------------------------------------------------------------------------

集合类型(set)
对外提供的功能和list类似，特殊之处在于可以自动去重，且是无序的，底层是一个String类型的无序集合，是一个value为null的hash表，添加，删除和查找的
复杂度都是O(1)
常用命令：
sadd k v1 v2 v3   将一个或多个值加入到集合key中
smembers k 取出该集合的所有值
sismember k v  判断k中是否存在v  返回1则存在
scard k  返回该集合的元素个数
srem k v1 v2  删除结合中的某个元素
spop k 随机从该集合中吐出一个值
srandmember k n 随机从集合中取出n个值，不删除
smove source destination value  把集合source中的一个值移到destination集合 （集合其实就是k）
sinter k1 k2 返回两个集合的交集元素
sunion k1 k2 返回两个集合的并集元素
sdiff k1 k2 返回两个集合的差集元素（k1中的，不包含k2中的）

数据结构
set数据结构是dict字典，字典是是用哈希表实现的
java中的HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象
Redis的set结构也一样，它的内部也使用hash结构，所有的value都指向同一个内部值

--------------------------------------------------------------------------------------------------------

哈希(Hash)类型
Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象
类似Java里面的Map<String, Object>
其结构如下：
value是一个Object

key                 value

user            field       value
                id          1
                name        张三
                age         20


常用命令：
hset k field value 给k集合中的field键赋value
hget k field 从k集合field取出value
hmset k field1 value1 field2 value2  批量设置hash值
hexists k field 查看哈表表k中，给定域是否存在
hkeys key 列出该hash集合的所有field
hvals key 列出该hash集合的所有value
hincrby k field increment 为哈希表key中的域field的值加上增量increment  如 hincrby user age 5  增加5岁
hsetnx key field value 将哈希表key中的域field的值设置为value,当且仅当域field不存在

数据结构
Hash类型的数据结构是两种：ziplist（压缩列表）,hashtable(哈希表),当field-values数量少且长度短时，使用ziplist,否则使用hashtable

------------------------------------------------------------------------------------------------------------------------

有序集合(Zset,全名SortedSet)
有序集合zset和普通集合set非常相似，也是一个没有重复元素的字符串集合
不同之处在于zset为每个成员都关联了一个评分(score),这个评分被用来按照从最低分到最高分的方式排列集合中的元素,集合的成员是唯一的，但是评分
可以是重复的。
因为元素是有序的。所以可以快速根据评分或者次序(pasition)来获取一个范围的元素
访问有序集合的中间元素也非常快，因此可以使用有序集合作为一个没有重复成员的智能列表。

常用命令：带中括号[]表示可有可无
zadd key score1 value1 score2 value2  将一个或多个member元素及其score值加入到有序集key当中
zrange key start stop [withscores] 返回有序集key中，下标在start stop之间的元素,带withscores,可以让分数一起和值返回到结果集。
zrangebyscore key min max [withscores] 从小到大返回有序集合key中所有score介于min和max之间（包括min,max）的成员
zrevrangebyscore key min max [withscores]  同上，改成从大到小
zincrby key increment value  为元素的score加上increment    如zincrby topn 50 java
zrem key value 删除该集合下,指定值的元素
zcount key min max 统计该集合，分数区间内的元素个数
zrank key value 返回该值在集合中的排名,从0开始

数据结构
zset是redis提供的一个特别的数据结构，一方面它等价于java的数据结构Map<String, Double>,可以给每一个元素value赋予一个权重score,另一方面它又
类似于TreeSet,内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表
zset底层使用了两种数据结构
(2)hash, hash的作用就是关联元素value和权重score,保障元素value的唯一性,可以通过元素value找到对应的score值
(2)跳跃表,跳跃表的目的在于给元素value排序，根据score的范围获取元素列表(即快速找到某个元素)
跳跃表由多层的链表组成

hash表可以根据元素获取评分，跳跃表可以根据评分获取元素

hash的数据结构如下：
也就是score变成了value

hash                    field   value

                        java    100
                        pho     200



--------------------------------------------------------------------------------------------------------

配置文件

1、Units单位
配置大小单位，开头定义了一些基本的度量单位,只支持bytes,不支持bit(位) 大小写不敏感

2、INCLUDES
包含其他文件

3、NETWORK
网络相关配置
bind 127.0.0.1  限制为本地链接，只有当前Linux下才能使用,如果在前面加上#号注掉，就可以支持远程链接
protected-mode  保护模式  可将本机访问的保护模式设置为no
port  端口号
tcp-backlog  ?
timeout 默认0   0表示远不超时，以秒为单位   指不操作redis多久后断开
tcp-keepalive 默认300s  每隔300秒检查一次链接是否活着，如果不活着则释放链接

4、GENERAL
daemonize  默认no   是否支持后台启动
pidfile   存放pid文件的位置，每个实例都会产生一个不同的pid文件， 就是存放进程号的地方
loglevel 默认notice   表示日志级别  在debug环境中能看到更详细的信息，类似java中的log级别
logfile  默认空 设置日志的输入文件

5、SECURITY
可以设置密码，默认没有密码
后续还有，等继续研究

--------------------------------------------------------------------------------------------------------

Redis事务
事务是一个单独的隔离操作，事务中的所有命令都会序列化，按顺序执行，事务在执行的过程中不会被其他客户端发来的命令请求打断
事务的主要作用就是串联多个命令防止别的命令插队

三个基本命令
1、Multi   组队阶段   组队阶段若有命令失败，执行时整个队列都会被取消
从输入Multi命令开始，之后输入的命令都会依次进入命令队列中，但不会执行，知道输入Exec之后，Redis会依次执行队列中的命令
2、discard 放弃组队
Multi命令后全部命令全部报销
3、Exec   执行
依次执行队列中的命令，执行过程中，若有命令执行失败，不会影响其他命令。

事务冲突问题
1、悲观锁   redis不支持悲观锁
2、乐观锁  乐观锁适用于多读的应用类型，这样可以提高吞吐量
原理，在更新数据的时候检查一下其他客户端有没有更新这个数据，使用了版本号机制

乐观锁的使用  ：WATCH key
在执行multi之前，先执行watch key1 [key2],可以监视一个或多个key，如果在执行之前这个(或这些)key被其他命令所改动，那么事务将被打断，全部命令都失效

Redis事务三特性

1、单独的隔离操作
事务中的所有命令都会序列化并按顺序执行，事务在执行的过程中不会被其他客户端命令打断
2、没有隔离级别的概念
事务提交前的任何指令都不会被执行
3、不保证原子性
事务中如果有一条命令执行失败，其他命令仍让会被执行，不会回滚

--------------------------------------------------------------------------------------------------------
秒杀案例

可以用linux的ab工具模仿并发

基本思路
创建一个库存key  类型是string
创建一个秒杀成功的用户key   类型是set

核心逻辑代码

函数入参有prodid商品id和uid用户id
String  kcKey = "sk:" + prodid + ":qt";
String userKey = "sk:" + prodid + ":user";

String kc = jedis.get(kcKey);
if(kc == null) {
    System.out.println("秒杀还没开始  请稍等")
}
//判断重复秒杀
Boolean sismember = jedis.sismember(userKey, uid);
if(sismerber) {
    System.out.println("已秒杀成功，不能重复秒杀")；
    jedis.close();
    return false
}
//判断库存是否小于1
if(Integer.parseInt(kc) < 0) {
    System.out.println("秒杀已结束")；
    jedis.close();
    return false
}

//秒杀过程
jedis.decr(kcKey);
jedis.sadd(userKey, uid);
System.out.println("秒杀成功了");
jedis.close();

以上的代码有可能会出现两个问题：
1、库存数量小于0：也就出现了超卖问题
2、连接超时问题：如果并发量过大，redis服务器无法处理那么多的连接，有的请求就必须等待，有可能会超时导致连接失败

以上问题的解决

1、连接超时问题：
用连接池解决,节省每次连接redis服务带来的消耗，把连接好的实例反复使用
获取jedis时不使用直接new的方式 即 Jedis jedis = new Jedis("192.168.44.168",6379);   //每次都会建立redis连接
采用连接池的方式  Jedis jedis = jedisPoolInstance.getResource();

2、超卖问题：通过乐观锁进行解决

解决方案代码

String  kcKey = "sk:" + prodid + ":qt";
String userKey = "sk:" + prodid + ":user";

//监视库存
jedis.watch(kcKey);

String kc = jedis.get(kcKey);
if(kc == null) {
    System.out.println("秒杀还没开始  请稍等")
}
//判断重复秒杀
Boolean sismember = jedis.sismember(userKey, uid);
if(sismerber) {
    System.out.println("已秒杀成功，不能重复秒杀")；
    jedis.close();
    return false
}
//判断库存是否小于1
if(Integer.parseInt(kc) < 0) {
    System.out.println("秒杀已结束")；
    jedis.close();
    return false
}

//秒杀过程
//使用事务
Transaction multi = jedis.multi();
//组队操作
multi.decr(kcKey);
multi.sadd(userKey, uid);
List<Object> results = multi.exec();
if(results == null || results.size() == 0) {
    System.out.println("秒杀失败了......");
    jedis.close();
    return false;
}

System.out.println("秒杀成功了");
jedis.close();

库存遗留问题  可以用LUA脚本
------------------------------------------------------------------------------------------------------------------------
主从复制和集群
总结起来，主服务器(master)负责写，写完将数据复制给从服务器，从服务器(slave)负责读
好处和特点：  一般是一主多从，不会只有一台从，也不能多主
1、实现读写分离，降低主服务器的压力
2、容灾的快速恢复(我理解应该是可用性的保证，比如一台从服务器挂掉，会切到另一台提供服务)

集群： 多个主从结构，可以解决主服务器挂掉的问题，当某个主服务器挂掉了，可以切换到另一个主服务器提供服务

一、在一台机器上搭建主从复制(1主2从)
1、先复制多个redis.conf文件，修改端口，配置文件可以直接用include引用共用模块,配置以下内容：
include /myredis/redis.conf
pidfile /var/run/redis_6379.pid
port 6379
dbfilename dump6379.rdb

2、之后同时启动3个服务
在客户端执行命令info replication 可以查看主从复制的相关信息，即看是主服务器还是从服务器，下面有多少台从服务器等信息

3、在客户端上执行命令 slaveof <主机ip> <主机port> 这样这个服务器就会成为指定服务器的从服务器 如slaveof 127.0.0.1 6379

问题：
1、从服务器如果挂掉了，重启后需要再执行slaveof命令重新成为从服务器，但是如果有哨兵，主服务器挂掉后重启会自动变成从服务器
2、主服务器挂掉了，重启后还是主服务器
3、主从复制的原理：
(1)从服务器连接上主服务器后，从服务器会向主服务器发送一个数据同步的消息
(2)主服务器接到同步消息后，会将当前服务器中数据先做持久化，即生成rdb文件，再把rdb文件发送给从服务器
(3)从服务器拿到文件后进入数据读取，完成复制。
(1)-(3)是从服务器主动的
(4)每次主服务器进行写操作后，会和从服务器进行数据同步，这个是服务器主动发起的

薪火相传：
背景：当从服务器很多的情况下，意味着主服务器需要向很多台从服务器发送同步数据，压力会增大，因此有了薪火相传
薪火相传就是从服务器也可以成为另一台从服务器的主服务器(但本质还是从)，从主服务器那获取同步数据后会再同步到下面的从服务器，缺点是如果和主服务器直接连接的从
服务器如果挂掉，后面的从服务器就无法获取同步数据

反客为主：如果主服务器挂掉，主服务器的直接从服务器可以成为主服务器
做法1：为在直接从服务器执行 slaveof no one   缺点，需要人工执行
做法2：哨兵模式，即反客为主的自动版，能够后台监控主机是否故障，如果故障则根据投票数自动将从库转为主库

哨兵模式
除了创建主从服务器之外，还要创建一台哨兵服务器
1、建立一个sentinel.conf文件作为哨兵的配置文件，文件的内容只有一行： sentinel monitor mymaster 127.0.0.1 6379 1
其中mymaster为监控对象(主机)起的服务器名称，1表示至少有多少个哨兵同意迁移的数量
2、启动哨兵服务器
3、主机挂了后选举的规则，选择的条件依次如下：
(1)选择优先级靠前的，再redis.conf中默认有 slave-priority 100 值越小优先级越高
(2)选择偏移量最大的：
参与复制的主从节点都会维护自身的复制偏移量，主节点(master)在处理完写入命令后，会把命令的字节长度做累加记录，统计在info relication的
master_repl_offset指标中。从节点(slave)每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。
从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量，统计在info relication的slave_repl_offset指标中
(3)选择runid最小的从服务：Redis服务器的随机标识符


主从的缺陷： 复制延迟，由于所有写操作都在主机操作，之后再同步更新到从机，所以这个过程有一定的延迟，特别是在系统繁忙的时候，Slave数量的增加也会
使这个问题更加严重。













