数据库的存储可分为行式数据库和列式数据库
1、行式数据库
把每一行作为一份数据结构去存储，特点是进行 selete * from users where id = 3 的操作会比较快，而
进行selete avg(age) from users等操作会比较慢
2、列式数据库
把每一列作为一份数据结构去存储，特点和行式相反，具体使用哪种看场景。

Redis:打破了传统的关系型数据库--以业务逻辑为依据进行存储，针对不同数据结构的类型，改变以性能为最优先的存储方式

安装步骤：
下载地址：https://redis.io/download/    redis只有linux版本和macOs版本
1、安装redis之前要先安装c语言的编译环境，如gcc，安装命令yum install gcc   安装完成后输入 gcc --version检查是否安装成功。
2、解压下载的redis压缩包，在目录下执行命令： tar -zxvf redis-6.2.1.tar.gz
3、在解压后的目录下执行指令  make 编译成C文件 （如果该过程报错  可以试试执行 make distclean清除编译文件）
4、再执行 make install 完成安装

Redis的启动：
在上述安装之后，redis在/usr/local/bin目录下
目录内有redis-server和redis-cli两个主要文件，一个是启动服务端启动文件  一个是客户端启动文件
启动方式用后台启动方式（前台启动方式不方便），进入redis的安装目录中，我放在/opt目录下，目录内有一个redis.conf配置文件，
可以把该目录复制到其他目录，如/etc目录中  执行命令：cp redis.conf /etc/redis.conf
把该配置文件中的daemonize改成yes，改完后在bin目录下执行命令： redis-server /etc/redis.conf  完成后台启动
ps -ef | grep redis 命令可以查看redis进程

Redis退出
执行命令 redis-cli shutdown 或 kill杀死进程


Redis的基本使用和相关知识（默认端口6379）
特性：单线程+多路IO复用技术------需深入了解

Redis默认有16个数据库，一般只使用0号库，指令selete n  切换到第n个数据库。


Redis基本用法

基本命令和字符串操作
keys *  查看库中所有key
set k v   设置key=k value=v，若k存在 则进行覆盖
setnx k v  只有k不存在的时候才会设置
mset k1 v1 k2 v2 k3 v3  设置多个kv对
msetnx 和上述同理，已存在的K不生效，原子性，只要有一个不成功，则全部失败
setex k 10 v  加上过期时间设置值
setrange name n abc  范围设置，在第n个位置设置abc
get k   获取值
mget k1 k2 k3  获取多个value
getrange k 0 3  范围获取，获取从0到3的值，上下限都包含  比如有“abcdef” geterange k 0 3返回abcd
getset k v 返回原值并将原值设置为新值v
selete n 切换到第n个数据库
exists k  查询k是否存在
type k  查看key是什么类型
strlen key 获取值的长度
del key 删除指定key数据（直接删除）
unlink key 同上（非阻塞删除，仅将key从keyspace元数据中删除，真正删除会在后续异步操作）
expire key 10  设置key的过期时间，单位是秒
ttl k  查看k还有多少时间过期，-1永不过期，-2已经过期
dbsize 查看当前数据库的key数量
flushdb 清除当前库
flushall 清除所有库内容
对value进行怎加或减少：
incr key
decr key
incrby key 10  可以设置步长
append k value  字符串的value，该命令将value追加到原有的值上

--------------------------------------------------------------------------------------------------------

字符串，String是Redis最基本的类型，String类型是二进制安全的，意味着可以包含任何数据，比如jpg图片，视频或者序列化的对象，只要能转成字符
串的数据都能存储，一个redis中字符串的value最多可以是512M
String的数据结构为简单动态字符串,内部结构类似java的ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配，比如一个字符串的空
间为capacity，实际长度是len,capacity>len,当len达到一定长度时会扩容capacity，当len小于1M时，扩容的方式是capacity*2,如果超过1M，则
扩容一次的方式是capacity+1M,最长可以扩容到512M

--------------------------------------------------------------------------------------------------------

列表类型（List）----单建多值
简单的字符串列表，按插入排序，底层数据结构是双向链表，对两端的操作性能高，当使用下标操作中间节点性能差。因此链表查询效率较低
常用命令：
lpush k v1 v2 v3  从左边加入多个值，类似入栈
lrange k1 0 -1  从左边根据下标取值，-1表示之后所有，上述输入后输出结果为  v3 v2 v1
rpush 从右边插入多个值
lpop/rpop k  从左边/右边吐出一个值，出栈，值在键在，没值键亡。
rpoplpush k1 k2 从k1列表出栈一个值并入栈到k2左边。
lindex k index 根据索引（index）取出以k为键的值（从左到右，下标从0开始）。
llen k 返回长度
linsert k before/after value newvalue 在value前面/后面插入值newvalue
lrem k n value 从左边删除n个value(从左到右)  比如 k1  a b c a d e a   执行lrem k1 2 a 结果变成 b c d e a
lset k index value 将k下标为index的值设置为value

数据结构：quickList 快速列表
在列表元素较少的情况下会用一块连续的内存块来存储数据，这个内存块叫压缩列表(ziplist),ziplist里面的元素紧挨着,当数据多时，再
用指针把多块ziplist串起来，这样比普通链表节省了一些存放指针的空间。

--------------------------------------------------------------------------------------------------------

集合类型(set)
对外提供的功能和list类似，特殊之处在于可以自动去重，且是无序的，底层是一个String类型的无序集合，是一个value为null的hash表（只有key? key就
是value?）添加，删除和查找的复杂度都是O(1)
常用命令：
sadd k v1 v2 v3   将一个或多个值加入到集合key中
smembers k 取出该集合的所有值
sismember k v  判断k中是否存在v  返回1则存在
scard k  返回该集合的元素个数
srem k v1 v2  删除结合中的某个元素
spop k 随机从该集合中吐出一个值
srandmember k n 随机从集合中取出n个值，不删除
smove source destination value  把集合source中的一个值移到destination集合 （集合其实就是k）
sinter k1 k2 返回两个集合的交集元素
sunion k1 k2 返回两个集合的并集元素
sdiff k1 k2 返回两个集合的差集元素（k1中的，不包含k2中的）

数据结构
set数据结构是dict字典，字典是是用哈希表实现的
java中的HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象
Redis的set结构也一样，它的内部也使用hash结构，所有的value都指向同一个内部值

--------------------------------------------------------------------------------------------------------

哈希(Hash)类型
Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象
类似Java里面的Map<String, Object>
其结构如下：
value是一个Object

key                 value

user            field       value
                id          1
                name        张三
                age         20


常用命令：
hset k field value 给k集合中的field键赋value
hget k field 从k集合field取出value
hmset k field1 value1 field2 value2  批量设置hash值
hexists k field 查看哈表表k中，给定域是否存在
hkeys key 列出该hash集合的所有field
hvals key 列出该hash集合的所有value
hincrby k field increment 为哈希表key中的域field的值加上增量increment  如 hincrby user age 5  增加5岁
hsetnx key field value 将哈希表key中的域field的值设置为value,当且仅当域field不存在

数据结构
Hash类型的数据结构是两种：ziplist（压缩列表）,hashtable(哈希表),当field-values数量少且长度短时，使用ziplist,否则使用hashtable

--------------------------------------------------------------------------------------------------------

有序集合(Zset,全名SortedSet)
有序集合zset和普通集合set非常相似，也是一个没有重复元素的字符串集合
不同之处在于zset为每个成员都关联了一个评分(score),这个评分被用来按照从最低分到最高分的方式排列集合中的元素,集合的成员是唯一的，但是评分
可以是重复的。
因为元素是有序的。所以可以快速根据评分或者次序(pasition)来获取一个范围的元素
访问有序集合的中间元素也非常快，因此可以使用有序集合作为一个没有重复成员的智能列表。

常用命令：带中括号[]表示可有可无
zadd key score1 value1 score2 value2  将一个或多个member元素及其score值加入到有序集key当中
zrange key start stop [withscores] 返回有序集key中，下标在start stop之间的元素,带withscores,可以让分数一起和值返回到结果集。
zrangebyscore key min max [withscores] 从小到大返回有序集合key中所有score介于min和max之间（包括min,max）的成员
zrevrangebyscore key min max [withscores]  同上，改成从大到小
zincrby key increment value  为元素的score加上increment    如zincrby topn 50 java
zrem key value 删除该集合下,指定值的元素
zcount key min max 统计该集合，分数区间内的元素个数
zrank key value 返回该值在集合中的排名,从0开始

数据结构
zset是redis提供的一个特别的数据结构，一方面它等价于java的数据结构Map<String, Double>,可以给每一个元素value赋予一个权重score,另一方面它又
类似于TreeSet,内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表
zset底层使用了两种数据结构
(2)hash, hash的作用就是关联元素value和权重score,保障元素value的唯一性,可以通过元素value找到对应的score值
(2)跳跃表,跳跃表的目的在于给元素value排序，根据score的范围获取元素列表(即快速找到某个元素)

hash的数据结构如下：
也就是score变成了value

hash                    field   value

                        java    100
                        pho     200



--------------------------------------------------------------------------------------------------------

配置文件

1、Units单位
配置大小单位，开头定义了一些基本的度量单位,只支持bytes,不支持bit(位) 大小写不敏感

2、INCLUDES
包含其他文件

3、NETWORK
网络相关配置
bind 127.0.0.1  限制为本地链接，只有当前Linux下才能使用,如果在前面加上#号注掉，就可以支持远程链接
protected-mode  保护模式  可将本机访问的保护模式设置为no
port  端口号
tcp-backlog  ?
timeout 默认0   0表示远不超时，以秒为单位   指不操作redis多久后断开
tcp-keepalive 默认300s  每隔300秒检查一次链接是否活着，如果不活着则释放链接

4、GENERAL
daemonize  默认no   是否支持后台启动
pidfile   存放pid文件的位置，每个实例都会产生一个不同的pid文件， 就是存放进程号的地方
loglevel 默认notice   表示日志级别  在debug环境中能看到更详细的信息，类似java中的log级别
logfile  默认空 设置日志的输入文件

5、SECURITY
可以设置密码，默认没有密码
后续还有，等继续研究

--------------------------------------------------------------------------------------------------------









