
Java技术体系包括了  java语言，各硬件平台上虚拟机的实现，Class文件格式，Java类库API，以及第三方库
其中 java语言，类库和虚拟机构成JDK，是Java程序开发的最小环境
java虚拟机和java SE API子集构成JRE，是java程序运行的标准环境

常量池：https://www.cnblogs.com/syp172654682/p/8082625.html
https://blog.csdn.net/u011069294/article/details/107415210  方法区的内容
常量池分为静态常量池和运行时常量池，静态常量池是存在于编译好字节码文件中，是静态的，运行时常量池是在
进行类加载后将上述的字节码静态内容加载到内存中（方法区中的常量池），并在需要的时候解析。
常量池的好处：常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享
程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池

目前我的理解是，运行时常量池是在虚拟机进行类加载后，把class文件的静态常量池加载到内存中保存于方法区内，动态常量池的内容和静态常量池
内容基本一致（每个类都有一个常量池，除了double和），但是动态常量池在程序运行期间还能增加内容，比如可以调用String.intern()方法增加常
量池内的字符串常量，其他类型的常量池则两者一致,不同类好像共享一个运行时常量池，但是每个类的静态常量池是分开的。
String.intern()方法会在常量池检查是否有和当前字符串一样的常量，有则返回该常量的引用，没有则创建后再返回引用(jdk7之前，如果常量池不存
在该字符串则拷贝一个到常量池，而jdk7之后拷贝的是该字符串在堆中的引用)

类被初始化的情况：发生主动引用的时候会立刻被初始化，当然之前的环节也要完成。
主动引用的情况：1、new该类的对象 2、读写一个类型的静态字段 3、调用一个类型的静态方法 4、使用反射包的方法堆类型进行反射调用
5、初始化一个类时其父类需要先初始化  6、一个接口定义了default方法，实现该接口的类初始化之前该接口需要被初始化。
发生被动引用则不会初始化
被动引用的情况：1、子类引用父类的静态字段，子类不会被初始化   2、new一个对象的数组，元素对象不会被初始化，初始化的是该类型的数组对象，该对象是由
虚拟机自动生成的

静态变量和静态常量的区别
静态变量是随着类加载而加载的，在链接阶段初始化为零值，在初始化阶段才被赋指定的值。
静态常量是编译后就存在于class文件的静态常量池里面，如果被其他类B引用，会在编译阶段通过常量传播优化，直接将该常量也直接存到该类的静态常量池中，之后
两个类没有任何关系，即如果B被初始化也不会引起编译前被引用类的初始化。 静态常量的处理方式和字面值差不多。

整型常量池：
虚拟机为各种整型的包装类（Byte,Short,Integer,Long,Character,Boolean）都实现了常量池，但是不像字符串常量值那样可以变动，整型常量池的内容
是固定的-128~127，以Integer为例，意思就是当你的int转Integer时，如果范围在-128~127之间，则直接在常量池（提前缓存好的Interger数组）里拿，如
超出范围，则重新new一个。

类的加载过程

加载-->验证-->准备-->解析-->初始化-->使用-->卸载
这几个过程虽然有固定的开始时间，但是是交叉执行（解析除外），比如加载先于验证，但是要加载成功肯定要验证成功。

加载:
加载是整个类加载过程的第一个阶段，主要完成以下三件事：
1、通过类的全限定名区获取类的二进制字节流
2、将二进制流中的静态存储结构转为方法区内的运行时数据结构
3、在堆中实例化该类的Class对象，作为程序访问该类数据的入口。
以上三个阶段，第一个阶段是可控阶段，灵活度高。
注：数组类不通过类加载器创建，是由虚拟机在内存中动态构造出来的（元素类型不一样，构造出来的数组类不一样），数组的一些方法或属性，如clone(),length
等都是由这个类提供的。
类加载器：
实现“通过一个类的全限定名去获取该类的二进制字节流”动作的代码被称为类加载器。
对于任意一个类，其唯一性是由类加载器和这个类本身共同确定的，每个类加载器都有一个独立的类名称空间。
在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader），这个类加载器使用C++语言实现[1]，是虚拟机自身
的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。


验证：
验证的内容是class文件内的字节流，是否符合java虚拟机规范，目的是防止java虚拟机自身的安全受到危害，被恶意代码攻击。
验证的内容包括了：1、文件格式验证 2、元数据验证 3、字节码验证 4、符号引用验证

准备：
准备阶段进行了类变量（静态变量）的内存分配和零值初始化，真正的赋值在初始化阶段执行类构造器内进行（clinit()方法）。
类常量则直接在准备阶段进行初始化，比如public static final int value = 123;  value属性在该阶段则直接赋值为123。

解析：待研究

初始化：
是类加载过程的最后一个步骤，主导权从虚拟机转到应用程序代码的阶段，该阶段主要执行类构造器clinit()方法。（与类的构造函数init()区分开）
clinit()方法是由编译器自动生成的，编译器收集类中所有类变量（静态变量）和静态语句块中语句并合并产生，收集的语句顺序和语句在源文件中出现的顺序一致，
而静态语句块中只能访问定义在语句块之前的变量，对于之后的变量，只能赋值但不能访问。
clinit()在调用前会优先调用父类的clinit(),因此第一个被指定的类构造器肯定是Object类型。
clinit()并非必须的，若类中没有静态语句块或者堆类变量的赋值操作，则编译器可以不为这个类生成clinit()方法
接口中没有静态语句块，但是又变量初始化的赋值操作，因此也可以有clinit()函数，和类不同的是，接口不用先执行父接口的clinit()方法，除非使用了父接口中
的变量。

clinit()是由用户线程去执行的，当有多个线程同时初始化一个类的时候，只有一个线程会真正去执行这个类构造器，其他线程则阻塞等待，直到活动线程执行完
clinit()方法，如果clinit()方法耗时很长，那么可能会造成多个线程的阻塞。
同一个类加载器下，一个类的clinit()只会被执行一次，其他线程不会再执行。















